class t{constructor(t,e=null,s=null,i=0){this.radix=t,null!==e&&null!==s?(this.bsEnc=e,this.bsDec=s):[this.bsEnc,this.bsDec]=this.constructor.calcBS(t),this.decPadVal=i}static calcBS(t){let e=t<8?t:Math.ceil(256/t);for(;e>8&&!(e%8);)e/=8;let s=0;for(;8*s*Math.log(2)/Math.log(t)<e;)s++;return[s,Math.ceil(8*s*Math.log(2)/Math.log(t))]}encode(t,e,s=!1,i=null){let n=this.bsEnc;0===n&&(n=t.byteLength);let r="";const a=n?(n-t.length%n)%n:0,o=new Array(a).fill(0);let l;s?(t.reverse(),l=[...o,...t]):l=[...t,...o];for(let t=0,s=l.length;t<s;t+=n){let s=0n;for(let e=t;e<t+n;e++)s=(s<<8n)+BigInt(l[e]);const o=new Array;let h,c=s;for(;c>=this.radix;)[c,h]=this.divmod(c,this.radix),o.unshift(parseInt(h,10));for(o.unshift(parseInt(c,10));o.length<this.bsDec;)o.unshift(0);let u="";o.forEach((t=>u=u.concat(e[t]))),i&&(u=i(u,a)),r=r.concat(u)}return[r,a]}decode(t,e,s=!1){if(!t)return new Uint8Array(0);let i=this.bsDec;const n=new Array;let r;if(t.split("").forEach((t=>{const s=e.indexOf(t);s>-1&&n.push(s)})),0===i)i=n.length;else{r=(i-n.length%i)%i;const t=new Array(r).fill(this.decPadVal);s?n.unshift(...t):n.push(...t)}let a=new Array;for(let t=0,e=n.length;t<e;t+=i){let e=0n;for(let s=0;s<i;s++)e+=BigInt(n[t+s])*this.pow(i-1-s);const s=new Array;let r,o=e;for(;o>=256;)[o,r]=this.divmod(o,256),s.unshift(parseInt(r,10));for(s.unshift(parseInt(o,10));s.length<this.bsEnc;)s.unshift(0);a=a.concat(s)}if(s){for(;!a[0];)a.shift();a.length||a.push(0),a.reverse()}else if(this.bsDec){const t=this.padChars(r);a.splice(a.length-t)}return Uint8Array.from(a)}padBytes(t){return Math.floor(t*this.bsDec/this.bsEnc)}padChars(t){return Math.ceil(t*this.bsEnc/this.bsDec)}pow(t){return BigInt(this.radix)**BigInt(t)}divmod(t,e){return[t,e]=[BigInt(t),BigInt(e)],[t/e,t%e]}}class e{constructor(t){this.root=t,"charsets"in t&&this.charsetUserToolsConstructor(),this.smartInput=new s,this.smartOutput=new i}charsetUserToolsConstructor(){this.root.addCharset=(t,e)=>{if("string"!=typeof t)throw new TypeError("The charset name must be a string.");const s=this.root.converter.radix;let i=s;if("string"==typeof e||Array.isArray(e))i=e.length,e=new Set(e);else if(!(e instanceof Set))throw new TypeError("The charset must be one of the types:\n'str', 'set', 'array'.");if(e.size!==s)throw i===s?new Error("There were repetitive chars found in your charset. Make sure each char is unique."):new Error(`The the length of the charset must be ${s}.`);e=[...e].join(""),this.root.charsets[t]=e,console.log(`New charset added with the name '${t}' added and ready to use`)},this.root.setDefaultVersion=t=>[this.root.version]=this.validateArgs([t])}makeArgList(t){return t.map((t=>`'${t}'`)).join(", ")}toSignedStr(t,e){return t=t.replace(/^0+(?!$)/,""),e&&(t="-".concat(t)),t}extractSign(t){let e=!1;return"-"===t[0]&&(e=!0,t=t.slice(1)),[t,e]}normalizeOutput(t){let e=2**Math.ceil(Math.log(t.byteLength)/Math.log(2));e=Math.max(e,2);const s=e-t.byteLength;if(s){const i=new Uint8Array(e);i.set(t,s),t=i}return t}negate(t){t.forEach(((e,s)=>t[s]=255^e));const e=t.byteLength-1;t[e]+=1}toSignedArray(t,e){return t=this.normalizeOutput(t),e&&this.negate(t),t}invalidArgument(t,e,s){const i=this.root.isMutable.signed?"\n * 'signed' to disable, 'unsigned', to enable the use of the twos's complement for negative integers":"",n=this.root.isMutable.littleEndian?"\n * 'be' for big , 'le' for little endian byte order for case conversion":"",r=this.root.isMutable.padding?"\n * 'pad' to fill up, 'nopad' to not fill up the output with the particular padding":"",a=this.root.isMutable.upper?"\n * valid args for changing the encoded output case are 'upper' and 'lower'":"",o=`\n * valid args for the output type are ${this.makeArgList(s)}`,l=e?`\n * the options for version (charset) are: ${this.makeArgList(e)}`:"";throw new TypeError(`'${t}'\n\nValid parameters are:${i}${n}${r}${a}${o}${l}\n\nTraceback:`)}validateArgs(t,e=!1){const s={version:this.root.version,signed:this.root.signed,littleEndian:this.root.littleEndian,padding:this.root.padding,outputType:"buffer"};if(!t.length)return s;const i=Object.keys(this.root.charsets),n=this.smartOutput.typeList,r={littleEndian:["be","le"],padding:["nopad","pad"],signed:["unsigned","signed"],upper:["lower","upper"]};if(t.forEach((t=>{if(t=String(t).toLowerCase(),i.includes(t))s.version=t;else if(n.includes(t))s.outputType=t;else{let e=!0;for(const i in r)if(r[i].includes(t)){if(e=!1,!this.root.isMutable[i])throw TypeError(`Argument '${t}' is not allowed for this type of converter.`);s[i]=Boolean(r[i].indexOf(t))}e&&this.invalidArgument(t,i,n)}})),s.padding&&s.signed&&(s.padding=!1,this.constructor.warning("Padding was set to false due to the signed conversion.")),e)for(const t in s)this.root[t]=s[t];return s}signError(){throw new TypeError("The input is signed but the converter is not set to treat input as signed.\nYou can pass the string 'signed' to the decode function or when constructing the converter.")}static warning(t){Object.prototype.hasOwnProperty.call(console,"warn")?console.warn(t):console.log(`___\n${t}\n`)}}class s{makeDataView(t){const e=new ArrayBuffer(t);return new DataView(e)}floatingPoints(t,e=!1){let s;if(t>12e-39&&t<34e37)s=this.makeDataView(4),s.setFloat32(0,t,e);else{if(!(t>23e-309&&t<17e307))throw new RangeError("Float is too complex to handle. Convert it to bytes manually before encoding.");s=this.makeDataView(8),s.setFloat64(0,t,e)}return s}numbers(t,e=!1){let s;if(Number.isInteger(t)){if(!Number.isSafeInteger(t)){let e,s,i;throw t<0?(e=Number.MIN_SAFE_INTEGER,s="smaller",i="MIN"):(e=Number.MAX_SAFE_INTEGER,s="bigger",i="MAX"),new RangeError(`The provided integer is ${s} than ${i}_SAFE_INTEGER: '${e}'\nData integrity is not possible. Use a BigInt to avoid this issue.`)}t<0?t<-2147483648?(s=this.makeDataView(8),s.setBigInt64(0,BigInt(t),e)):t<-32768?(s=this.makeDataView(4),s.setInt32(0,t,e)):(s=this.makeDataView(2),s.setInt16(0,t,e)):t>0?t>4294967295?(s=this.makeDataView(8),s.setBigUint64(0,BigInt(t),e)):t>65535?(s=this.makeDataView(4),s.setUint32(0,t,e)):(s=this.makeDataView(2),s.setInt16(0,t,e)):s=new Uint16Array([0])}else s=this.floatingPoints(t,e);return new Uint8Array(s.buffer)}bigInts(t,e=!1){const s=new Array,i=e?"push":"unshift";if(t>0){const e=18446744073709551616n;for(;t>=e;)s[i](t%e),t>>=64n}else if(t<0){const e=-9223372036854775808n;for(;t<=e;)s[i](t%e),t>>=64n}s[i](t);const n=8*s.length,r=new ArrayBuffer(n),a=new DataView(r);return s.forEach(((t,s)=>{const i=8*s;a.setBigUint64(i,t,e)})),new Uint8Array(a.buffer)}toBytes(t,e=!1,s=!1){let i,n=!1,r=!1;if(t instanceof ArrayBuffer)i=new Uint8Array(t),r=!0;else if(ArrayBuffer.isView(t))i=new Uint8Array(t.buffer),r=!0;else if("string"==typeof t||t instanceof String)i=(new TextEncoder).encode(t);else if("number"!=typeof t||isNaN(t)||t===1/0)if("bigint"==typeof t)e&&t<0&&(n=!0,t*=-1n),i=this.bigInts(t,s);else{if(!Array.isArray(t))throw new TypeError("The provided input type can not be processed.");{const e=new Array;for(const s of t)e.push(...this.toBytes(s));i=Uint8Array.from(e)}}else e&&t<0&&(n=!0,t*=-1),i=this.numbers(t,s);return[i,n,r]}}class i{constructor(){this.typeList=this.constructor.validTypes()}getType(t){if(!this.typeList.includes(t))throw new TypeError(`Unknown output type: '${t}'`);return t}makeTypedArrayBuffer(t,e,s){const i=t.byteLength,n=(e-t.byteLength%e)%e;let r=t;if(n){r=new Uint8Array(i+n);const e=s?n:0;r.set(t,e)}return r.buffer}makeTypedArray(t,e,s){let i;if("int16"===e||"uint16"===e){const n=this.makeTypedArrayBuffer(t,2,s);i="int16"===e?new Int16Array(n):new Uint16Array(n)}else if("int32"===e||"uint32"===e){const n=this.makeTypedArrayBuffer(t,4,s);i="int32"===e?new Int32Array(n):new Uint32Array(n)}else if("bigint64"===e||"biguint64"===e){const n=this.makeTypedArrayBuffer(t,8,s);i="bigint64"===e?new BigInt64Array(n):new BigUint64Array(n)}return i}compile(t,e,s=!1,i=!1){let n;if("buffer"===(e=this.getType(e)))n=t.buffer;else if("bytes"===e||"Uint8"===e)n=t;else if("int8"===e)n=new Int8Array(t.buffer);else if("view"===e)n=new DataView(t.buffer);else if("str"===e)n=(new TextDecoder).decode(t);else if("number"===e){n=t,s&&n.reverse();let e=0n;n.forEach((t=>e=(e<<8n)+BigInt(t))),n=e<Number.MAX_SAFE_INTEGER?Number(e):e,i&&(n=-n)}else n=this.makeTypedArray(t,e,s);return n}static validTypes(){return["bigint64","biguint64","buffer","bytes","int8","int16","int32","number","str","uint8","uint16","uint32","view"]}}class n{constructor(...s){this.charsets={all:"*",list:"*",default:"1",tmark:"|"},this.base10Chars="0123456789",this.converter=new t(10,0,0),this.littleEndian=!0,this.outputType="buffer",this.padding=!1,this.signed=!1,this.upper=!1,this.utils=new e(this),this.version="default",this.isMutable={littleEndian:!1,padding:!1,signed:!0,upper:!0},this.utils.validateArgs(s,!0)}encode(t,...e){const s=this.utils.validateArgs(e);let i,n;[i,n]=this.utils.smartInput.toBytes(t,s.signed,s.littleEndian);let r=this.converter.encode(i,this.base10Chars,s.littleEndian)[0],a=BigInt(r),o="";if(a>Number.MAX_SAFE_INTEGER)throw new RangeError("Invalid string length.");return console.log(this.charsets[s.version]),o=this.charsets[s.version].repeat(Number(a)),o=this.utils.toSignedStr(o,n),s.upper&&(o=o.toUpperCase()),o}decode(t,...e){const s=this.utils.validateArgs(e);let i;t=String(t),[t,i]=this.utils.extractSign(t);const n=new RegExp(`[^${this.charsets[s.version]}]`,"g");t=t.replace(n,""),t=String(t.length),console.log(t);const r=this.converter.decode(t,this.base10Chars,s.littleEndian);return this.utils.smartOutput.compile(r,s.outputType,s.littleEndian,i)}}class r{constructor(...s){this.charsets={default:"0123456789abcdef"},this.converter=new t(16,1,2),this.littleEndian=!1,this.outputType="buffer",this.padding=!1,this.signed=!1,this.upper=!1,this.utils=new e(this),this.version="default",this.isMutable={littleEndian:!1,padding:!1,signed:!0,upper:!0},this.utils.validateArgs(s,!0)}encode(t,...e){const s=this.utils.validateArgs(e);let i,n;[i,n]=this.utils.smartInput.toBytes(t,s.signed);let r=this.converter.encode(i,this.charsets[s.version])[0];return s.signed&&(r=this.utils.toSignedStr(r,n)),s.upper&&(r=r.toUpperCase()),r}decode(t,...e){const s=this.utils.validateArgs(e);let i;t=String(t),[t,i]=this.utils.extractSign(t),i&&!s.signed&&this.utils.signError(),(t=(t=t.replace(/^0x/,"")).toLowerCase()).length%2&&(t="0".concat(t));let n=this.converter.decode(t,this.charsets[s.version]);return s.signed&&(n=this.utils.toSignedArray(n,i)),this.utils.smartOutput.compile(n,s.outputType,s.littleEndian,i)}}class a{constructor(...s){this.charsets={rfc3548:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",rfc4648:"0123456789ABCDEFGHIJKLMNOPQRSTUV",crockford:"0123456789ABCDEFGHJKMNPQRSTVWXYZ"},this.converter=new t(32,5,8),this.littleEndian=!1,this.outputType="buffer",this.padding=!0,this.signed=!1,this.upper=!1,this.utils=new e(this),this.version="rfc4648",this.isMutable={littleEndian:!0,padding:!0,signed:!0,upper:!0},this.utils.validateArgs(s,!0)}encode(t,...e){const s=this.utils.validateArgs(e);let i,n,r,a;if([i,n]=this.utils.smartInput.toBytes(t,s.signed,s.littleEndian),[r,a]=this.converter.encode(i,this.charsets[s.version],s.littleEndian),s.littleEndian)r=this.utils.toSignedStr(r,n);else if(a){const t=this.converter.padBytes(a);r=r.slice(0,r.length-t),s.padding&&(r=r.concat("=".repeat(t)))}return s.upper||(r=r.toLowerCase()),r}decode(t,...e){const s=this.utils.validateArgs(e);let i;t=String(t),[t,i]=this.utils.extractSign(t),i&&!s.signed&&this.utils.signError(),t=t.toUpperCase();const n=this.converter.decode(t,this.charsets[s.version],s.littleEndian);return this.utils.smartOutput.compile(n,s.outputType,s.littleEndian,i)}}class o{constructor(...s){this.charsets={default:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",bitcoin:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",flickr:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"},this.converter=new t(58,0,0),this.littleEndian=!1,this.outputType="buffer",this.padding=!0,this.signed=!1,this.upper=null,this.utils=new e(this),this.version="default",this.isMutable={littleEndian:!0,padding:!0,signed:!0,upper:!1},this.utils.validateArgs(s,!0)}encode(t,...e){const s=this.utils.validateArgs(e);let i,n,r;if([i,,n]=this.utils.smartInput.toBytes(t,s.signed,s.littleEndian),s.padding&&n){let t=0,e=0;for(;!i[t];)e++,t++;r=this.converter.encode(i,this.charsets[s.version])[0],e&&(r="1".repeat(e).concat(r))}else r=this.converter.encode(i,this.charsets[s.version])[0];return r}decode(t,...e){const s=this.utils.validateArgs(e);let i;if(t=String(t),s.padding){let e=0,n=0;for(;"1"===t[e];)n++,e++;i=this.converter.decode(t,this.charsets[s.version]),n&&(i=Uint8Array.from([...new Array(n).fill(0),...i]))}else i=this.converter.decode(t,this.charsets[s.version]);return this.utils.smartOutput.compile(i,s.outputType)}}class l{constructor(...s){const i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";this.charsets={default:i.concat("+/"),urlsafe:i.concat("-_")},this.converter=new t(64,3,4),this.littleEndian=!1,this.outputType="buffer",this.padding=!0,this.signed=!1,this.upper=null,this.utils=new e(this),this.version="default",this.isMutable={littleEndian:!1,padding:!0,signed:!1,upper:!1},this.utils.validateArgs(s,!0)}encode(t,...e){const s=this.utils.validateArgs(e),i=this.utils.smartInput.toBytes(t,s.signed,s.littleEndian)[0];let n,r;if([n,r]=this.converter.encode(i,this.charsets[s.version]),r){const t=this.converter.padBytes(r);n=n.slice(0,n.length-t),s.padding&&(n=n.concat("=".repeat(t)))}return n}decode(t,...e){const s=this.utils.validateArgs(e);t=String(t);const i=this.converter.decode(t,this.charsets[s.version]);return this.utils.smartOutput.compile(i,s.outputType)}}class h{constructor(...s){const i="!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstu";this.charsets={ascii85:i,adobe:i,rfc1924:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$%&()*+-;<=>?@^_`{|}~",z85:"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-:+=^!/*?&<>()[]{}@%$#"},this.converter=new t(85,4,5,84),this.littleEndian=!1,this.outputType="buffer",this.padding=!1,this.signed=!1,this.upper=null,this.utils=new e(this),this.version="ascii85",this.isMutable={littleEndian:!1,padding:!1,signed:!1,upper:!1},this.utils.validateArgs(s,!0)}encode(t,...e){const s=this.utils.validateArgs(e),i=this.utils.smartInput.toBytes(t,s.signed,s.littleEndian)[0];let n,r,a=null;if(s.version.match(/adobe|ascii85/)&&(a=(t,e)=>e||"!!!!!"!==t?t:"z"),[n,r]=this.converter.encode(i,this.charsets[s.version],!1,a),r){const t=this.converter.padBytes(r);n=n.slice(0,n.length-t)}return"adobe"===s.version&&(n=`<~${n}~>`),n}decode(t,...e){const s=this.utils.validateArgs(e);t=String(t),s.version.match(/adobe|ascii85/)&&(t=t.replace(/z/g,"!!!!!"),"adobe"===s.version&&(t=t.replace(/^<~|~>$/g,"")));const i=this.converter.decode(t,this.charsets[s.version]);return this.utils.smartOutput.compile(i,s.outputType)}}class c{constructor(...t){this.byteOrder="BE",this.charsets={default:'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,./:;<=>?@[]^_`{|}~"'},this.littleEndian=!1,this.outputType="buffer",this.padding=!1,this.signed=!1,this.upper=null,this.utils=new e(this),this.version="default",this.isMutable={littleEndian:!1,padding:!1,signed:!1,upper:!1},this.utils.validateArgs(t,!0)}encode(t,...e){const s=this.utils.validateArgs(e),i=this.utils.smartInput.toBytes(t,s.signed,s.littleEndian)[0];let n=0,r=0,a="";const o=this.charsets[s.version];if(i.forEach((t=>{if(r+=t<<n,n+=8,n>13){let t,e,s=13,i=r%8192;i<89&&(s=14,i=r%16384),r>>=s,n-=s,[t,e]=this.divmod(i,91),a=`${a}${o[e]}${o[t]}`}})),n){let t,e;[t,e]=this.divmod(r,91),a=a.concat(o[e]),(n>7||r>90)&&(a=a.concat(o[t]))}return a}decode(t,...e){const s=this.utils.validateArgs(e);let i=(t=String(t)).length,n=!1;i%2&&(n=!0,i--);let r=0,a=0;const o=this.charsets[s.version],l=new Array;for(let e=0;e<i;e+=2){const s=o.indexOf(t[e])+91*o.indexOf(t[e+1]);r=(s<<a)+r,a+=s%8192>88?13:14;do{l.push(r%256),r>>=8,a-=8}while(a>7)}if(n){const e=t.charAt(i),s=o.indexOf(e);l.push(((s<<a)+r)%256)}const h=Uint8Array.from(l);return this.utils.smartOutput.compile(h,s.outputType)}divmod(t,e){return[Math.floor(t/e),t%e]}}class u{constructor(s,...i){if(!s||!Number.isInteger(s)||s<2||s>36)throw new RangeError("Radix argument must be provided and has to be an integer between 2 and 36.");this.charsets={selection:"0123456789abcdefghijklmnopqrstuvwxyz".substring(0,s)},this.converter=10===s?new t(10,0,0):new t(s),this.littleEndian=!(2===s||16===s),this.outputType="buffer",this.padding=!1,this.signed=!0,this.upper=!1,this.utils=new e(this),this.version="selection",this.isMutable={littleEndian:!1,padding:!1,signed:!1,upper:!0},this.utils.validateArgs(i,!0)}encode(t,...e){const s=this.utils.validateArgs(e);let i,n;[i,n]=this.utils.smartInput.toBytes(t,s.signed,s.littleEndian);let r=this.converter.encode(i,this.charsets[s.version],s.littleEndian)[0];return r=this.utils.toSignedStr(r,n),s.upper&&(r=r.toUpperCase()),r}decode(t,...e){const s=this.utils.validateArgs(e);let i;if(t=String(t),[t,i]=this.utils.extractSign(t),2===this.converter.radix){const e=(8-t.length%8)%8;t=`${"0".repeat(e)}${t}`}else if(16===this.converter.radix){const e=t.length%2;t=`${"0".repeat(e)}${t}`}console.log(t),t=t.toLowerCase();const n=this.converter.decode(t,this.charsets[s.version],s.littleEndian);return this.utils.smartOutput.compile(n,s.outputType,s.littleEndian,i)}}
/*
 * [BaseEx]{@link https://github.com/UmamiAppearance/BaseExJS}
 *
 * @version 0.4.0
 * @author UmamiAppearance [mail@umamiappearance.eu]
 * @license GPL-3.0 AND BSD-3-Clause (Base91, Copyright (c) 2000-2006 Joachim Henke)
 */class d{constructor(t="buffer"){this.base16=new r("default",t),this.base32_rfc3548=new a("rfc3548",t),this.base32_rfc4648=new a("rfc4648",t),this.base64=new l("default",t),this.base64_urlsafe=new l("urlsafe",t),this.base85adobe=new h("adobe",t),this.base85ascii=new h("ascii85",t),this.base85_z85=new h("z85",t),this.base91=new c("default",t)}}export{n as Base1,r as Base16,a as Base32,o as Base58,l as Base64,h as Base85,c as Base91,d as BaseEx,u as SimpleBase};
