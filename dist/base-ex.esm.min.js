class t{static toBytes(t){return ArrayBuffer.isView(t)&&(t=t.buffer),[new Uint8Array(t),!1,"bytes"]}}class e{static get typeList(){return["buffer","bytes","uint8","view"]}static getType(t){if(!e.typeList.includes(t))throw new TypeError(`Unknown output type: '${t}'`);return t}static compile(t,s){let i;return i="buffer"===(s=e.getType(s))?t.buffer:"view"===s?new DataView(t.buffer):t,i}}class s{static makeDataView(t){const e=new ArrayBuffer(t);return new DataView(e)}static floatingPoints(t,e=!1){const s=this.makeDataView(8);return s.setFloat64(0,t,e),s}static numbers(t,e=!1){let s,i;if(Number.isInteger(t)){if(i="int",!Number.isSafeInteger(t)){let e,s,i;throw t<0?(e=Number.MIN_SAFE_INTEGER,s="smaller",i="MIN"):(e=Number.MAX_SAFE_INTEGER,s="bigger",i="MAX"),new RangeError(`The provided integer is ${s} than ${i}_SAFE_INTEGER: '${e}'\nData integrity is not guaranteed. Use a BigInt to avoid this issue.\n(If you see this error although a float was provided, the input has to many digits before the decimal point to store the decimal places in a float with 64 bits.)`)}t<0?t<-2147483648?(s=this.makeDataView(8),s.setBigInt64(0,BigInt(t),e)):t<-32768?(s=this.makeDataView(4),s.setInt32(0,t,e)):(s=this.makeDataView(2),s.setInt16(0,t,e)):t>0?t>4294967295?(s=this.makeDataView(8),s.setBigUint64(0,BigInt(t),e)):t>65535?(s=this.makeDataView(4),s.setUint32(0,t,e)):(s=this.makeDataView(2),s.setInt16(0,t,e)):s=new Uint16Array([0])}else i="float",s=this.floatingPoints(t,e);return[new Uint8Array(s.buffer),i]}static bigInts(t,e=!1){const s=new Array,i=e?"push":"unshift",r=18446744073709551616n;if(t<0)for(;t<-9223372036854775808n;)s[i](t%r),t>>=64n;else for(;t>=r;)s[i](t%r),t>>=64n;s[i](t);const n=8*s.length,o=this.makeDataView(n);return s.forEach(((t,s)=>{const i=8*s;o.setBigUint64(i,t,e)})),new Uint8Array(o.buffer)}static toBytes(t,e){let s,i=!1,r="bytes";if(t instanceof ArrayBuffer)s=new Uint8Array(t.slice());else if(ArrayBuffer.isView(t))s=new Uint8Array(t.buffer.slice());else if("string"==typeof t||t instanceof String)s=(new TextEncoder).encode(t);else if("number"==typeof t){if(isNaN(t))throw new TypeError("Cannot proceed. Input is NaN.");if(t==1/0)throw new TypeError("Cannot proceed. Input is Infinity.");if(e.signed&&t<0&&(i=!0,t=-t),e.numberMode){const i=this.floatingPoints(t,e.littleEndian);s=new Uint8Array(i.buffer),r="float"}else[s,r]=this.numbers(t,e.littleEndian)}else if("bigint"==typeof t)e.signed&&t<0&&(i=!0,t*=-1n),s=this.bigInts(t,e.littleEndian),r="int";else{if(!Array.isArray(t))throw new TypeError("The provided input type can not be processed.");{const i=new Array;for(const s of t)i.push(...this.toBytes(s,e)[0]);s=Uint8Array.from(i)}}return[s,i,r]}}class i{static get typeList(){return["bigint64","bigint_n","biguint64","buffer","bytes","float32","float64","float_n","int8","int16","int32","int_n","str","uint8","uint16","uint32","uint_n","view"]}static getType(t){if(!this.typeList.includes(t))throw new TypeError(`Unknown output type: '${t}'`);return t}static makeTypedArrayBuffer(t,e,s,i){const r=t.byteLength,n=(e-t.byteLength%e)%e,o=i&&r>1?255:0;let a=t;if(n){a=new Uint8Array(r+n),a.fill(o);const e=s?0:n;a.set(t,e)}return a.buffer}static makeTypedArray(t,e,s,i){let r;if("int16"===e||"uint16"===e){const n=this.makeTypedArrayBuffer(t,2,s,i);r="int16"===e?new Int16Array(n):new Uint16Array(n)}else if("int32"===e||"uint32"===e||"float32"===e){const n=this.makeTypedArrayBuffer(t,4,s,i);r="int32"===e?new Int32Array(n):"uint32"===e?new Uint32Array(n):new Float32Array(n)}else if("bigint64"===e||"biguint64"===e||"float64"===e){const n=this.makeTypedArrayBuffer(t,8,s,i);r="bigint64"===e?new BigInt64Array(n):"biguint64"===e?new BigUint64Array(n):new Float64Array(n)}return r}static compile(t,e,i=!1,r=!1){let n;if(e=this.getType(e),r){let r;if(r=e.match(/^float/)?-this.compile(t,"float_n",i):-this.compile(t,"uint_n",i),"float_n"===e)return r;t=s.toBytes(r,{littleEndian:i,numberMode:!1,signed:!1})[0]}if("buffer"===e)n=t.buffer;else if("bytes"===e||"uint8"===e)n=t;else if("int8"===e)n=new Int8Array(t.buffer);else if("view"===e)n=new DataView(t.buffer);else if("str"===e)n=(new TextDecoder).decode(t);else if("uint_n"===e||"int_n"===e||"bigint_n"===e){if(1===t.length){const e=this.makeTypedArrayBuffer(t,2,i,r);t=new Uint8Array(e)}i&&t.reverse();let s=0n;t.forEach((t=>s=(s<<8n)+BigInt(t))),"uint_n"!==e&&(s=BigInt.asIntN(8*t.length,s)),n="bigint_n"!==e&&s>=Number.MIN_SAFE_INTEGER&&s<=Number.MAX_SAFE_INTEGER?Number(s):s}else if("float_n"===e)if(t.length<=4){let e;e=4===t.length?t:this.makeTypedArray(t,"float32",!1,r);n=new DataView(e.buffer).getFloat32(0,i)}else{if(!(t.length<=8))throw new RangeError("The provided input is to complex to be converted into a floating point.");{let e;e=8===t.length?t:this.makeTypedArray(t,"float64",!1,r);n=new DataView(e.buffer).getFloat64(0,i)}}else if("number"===e){if(8!==t.length)throw new TypeError("Type mismatch. Cannot convert into number.");const e=new Float64Array(t.buffer);n=Number(e)}else n=this.makeTypedArray(t,e,i,r);return n}}const r=s,n=i;class o extends TypeError{constructor(){super("The input is signed but the converter is not set to treat input as signed.\nYou can pass the string 'signed' to the decode function or when constructing the converter."),this.name="SignError"}}class a{constructor(t,e=!0){this.root=t,this.converterArgs={},"charsets"in t&&e&&this.#t()}setIOHandlers(t=r,e=n){this.inputHandler=t,this.outputHandler=e}#t(){this.root.addCharset=(t,e,s="",i=!0)=>{if("string"!=typeof t)throw new TypeError("The charset name must be a string.");const r=this.root.converter.radix;let n=r;if("string"==typeof e&&(e=[...e]),Array.isArray(e))n=e.length,e=new Set(e);else if(!(e instanceof Set))throw new TypeError("The charset must be one of the types:\n'str', 'set', 'array'.");if(e.size!==r)throw n===r?new Error("There were repetitive chars found in your charset. Make sure each char is unique."):new Error(`The length of the charset must be ${r}.`);e=[...e],this.root.charsets[t]=e,i&&console.info(`New charset '${t}' was added and is ready to use`)},this.root.setDefaultCharset=t=>{({version:t}=this.validateArgs([t])),this.root.version=t}}makeArgList(t){return t.map((t=>`'${t}'`)).join(", ")}toSignedStr(t,e){return t=t.replace(/^0+(?!$)/,""),e&&(t="-".concat(t)),t}extractSign(t){let e=!1;return"-"===t[0]&&(e=!0,t=t.slice(1)),[t,e]}invalidArgument(t,e,s,i){const r=i?"\n * valid declarations for IO handlers are 'bytesOnly', 'bytesIn', 'bytesOut'":"",n=this.root.isMutable.signed?"\n * pass 'signed' to disable, 'unsigned' to enable the use of the twos's complement for negative integers":"",o=this.root.isMutable.littleEndian?"\n * 'be' for big , 'le' for little endian byte order for case conversion":"",a=this.root.isMutable.padding?"\n * pass 'pad' to fill up, 'nopad' to not fill up the output with the particular padding":"",l=this.root.isMutable.upper?"\n * valid args for changing the encoded output case are 'upper' and 'lower'":"",h=`\n * valid args for the output type are ${this.makeArgList(s)}`,c=e?`\n * the options for version (charset) are: ${this.makeArgList(e)}`:"",u=Object.keys(this.converterArgs).length?`\n * converter specific args:\n   - ${(()=>Object.keys(this.converterArgs).map((t=>this.converterArgs[t].map((t=>`'${t}'`)).join(" and "))).join("\n   - "))()}`:"";throw new TypeError(`'${t}'\n\nInput parameters:${r}${n}${o}${a}${l}${h}${c}\n * valid args for integrity check are : 'integrity' and 'nointegrity'\n * 'number' for number-mode (converts every number into a Float64Array to keep the natural js number type)${u}\n\nTraceback:`)}validateArgs(s,i=!1){const o={integrity:this.root.integrity,littleEndian:this.root.littleEndian,numberMode:this.root.numberMode,outputType:this.root.outputType,padding:this.root.padding,signed:this.root.signed,upper:this.root.upper,version:this.root.version};for(const t in this.converterArgs)o[t]=this.root[t];if(!s.length)return i&&this.setIOHandlers(),o;const a=t=>!!s.includes(t)&&(s.splice(s.indexOf(t),1),!0),l=Object.prototype.hasOwnProperty.call(this.root,"charsets")?Object.keys(this.root.charsets):[],h={integrity:["nointegrity","integrity"],littleEndian:["be","le"],padding:["nopad","pad"],signed:["unsigned","signed"],upper:["lower","upper"],...this.converterArgs};if(i)if(a("bytes_only"))this.setIOHandlers(t,e);else{const s=a("bytes_in")?t:r,i=a("bytes_out")?e:n;this.setIOHandlers(s,i)}const c=this.outputHandler.typeList;if(a("number")&&(o.numberMode=!0,o.outputType="float_n"),s.forEach((t=>{if(t=String(t).toLowerCase(),l.includes(t))o.version=t;else if(c.includes(t))o.outputType=t;else{let e=!0;for(const s in h)if(h[s].includes(t)){if(e=!1,!this.root.isMutable[s])throw TypeError(`Argument '${t}' is not allowed for this type of converter.`);o[s]=Boolean(h[s].indexOf(t))}e&&this.invalidArgument(t,l,c,i)}})),o.padding&&o.signed&&(o.padding=!1,console.warn("Padding was set to false due to the signed conversion.")),i)for(const t in o)this.root[t]=o[t];return o}signError(){throw new o}}class l{constructor(t,e=null,s=null,i=0){this.radix=t,null!==e&&null!==s?(this.bsEnc=e,this.bsDec=s):[this.bsEnc,this.bsDec]=this.constructor.guessBS(t),this.decPadVal=i}static guessBS(t){let e=t<8?t:Math.ceil(256/t);for(;e>8&&!(e%8);)e/=8;let s=0;for(;8*s*Math.log(2)/Math.log(t)<e;)s++;return[s,Math.ceil(8*s*Math.log(2)/Math.log(t))]}encode(t,e,s=!1,i=null){let r=this.bsEnc;0===r&&(r=t.byteLength);let n="";const o=r?(r-t.length%r)%r:0,a=new Array(o).fill(0);let l;if(s?(t.reverse(),l=[...a,...t]):l=[...t,...a],10===this.radix){let t=0n;for(let e=0;e<r;e++)t=(t<<8n)+BigInt(l[e]);return[t.toString(),0]}for(let t=0,s=l.length;t<s;t+=r){let s=0n;for(let e=t;e<t+r;e++)s=(s<<8n)+BigInt(l[e]);const a=new Array;let h,c=s;for(;c>=this.radix;)[c,h]=this.divmod(c,this.radix),a.unshift(parseInt(h,10));for(a.unshift(parseInt(c,10));a.length<this.bsDec;)a.unshift(0);let u="";a.forEach((t=>u=u.concat(e[t]))),i&&(u=i(u,o)),n=n.concat(u)}return[n,o]}decode(t,e,s=[],i=!0,r=!1){if(!t)return new Uint8Array(0);let n=this.bsDec;const o=new Array;let a;if([...t].forEach((t=>{const r=e.indexOf(t);if(r>-1)o.push(r);else if(i&&-1===s.indexOf(t))throw new TypeError(`Invalid input. Character: '${t}' is not part of the charset.`)})),0===n)n=o.length;else{a=(n-o.length%n)%n;const t=new Array(a).fill(this.decPadVal);r?o.unshift(...t):o.push(...t)}let l=new Array;for(let t=0,e=o.length;t<e;t+=n){let e=0n;for(let s=0;s<n;s++)e+=BigInt(o[t+s])*this.pow(n-1-s);const s=new Array;let i,r=e;for(;r>=256;)[r,i]=this.divmod(r,256),s.unshift(parseInt(i,10));for(s.unshift(parseInt(r,10));s.length<this.bsEnc;)s.unshift(0);l=l.concat(s)}if(r){if(l.length>1){for(;!l[0];)l.shift();l.length||l.push(0),l.reverse()}}else if(this.bsDec){const t=this.padChars(a);l.splice(l.length-t)}return Uint8Array.from(l)}padBytes(t){return Math.floor(t*this.bsDec/this.bsEnc)}padChars(t){return Math.ceil(t*this.bsEnc/this.bsDec)}pow(t){return BigInt(this.radix)**BigInt(t)}divmod(t,e){return[t,e]=[BigInt(t),BigInt(e)],[t/e,t%e]}}class h{constructor(t=!0){this.charsets={},this.hasSignedMode=!1,this.integrity=!0,this.littleEndian=!1,this.numberMode=!1,this.outputType="buffer",this.padding=!1,this.padChars={default:""},this.signed=!1,this.upper=null,t&&(this.utils=new a(this)),this.version="default",this.isMutable={integrity:!0,littleEndian:!1,padding:!1,signed:!1,upper:!1}}encode(t,e,s,...i){const r=this.utils.validateArgs(i);let n,o,a;[n,o,a]=this.utils.inputHandler.toBytes(t,r);let l=null;e&&(l=e(r));let[h,c]=this.converter.encode(n,this.charsets[r.version],r.littleEndian,l);return r.signed&&(h=this.utils.toSignedStr(h,o)),r.upper&&(h=h.toUpperCase()),s&&(h=s({inputBytes:n,output:h,settings:r,zeroPadding:c,type:a})),h}decode(t,e,s,...i){const r=this.utils.validateArgs(i);t=String(t);let n=!1;this.hasSignedMode&&([t,n]=this.utils.extractSign(t),n&&!r.signed&&this.utils.signError()),this.isMutable.upper&&(t=t.toLowerCase()),e&&(t=e({input:t,settings:r}));let o=this.converter.decode(t,this.charsets[r.version],this.padChars[r.version],r.integrity,r.littleEndian);return s&&(o=s({input:t,output:o,settings:r})),this.utils.outputHandler.compile(o,r.outputType,r.littleEndian,n)}}class c extends h{constructor(...t){super(),delete this.addCharset,this.charsets.all=[..." !\"#$%&'()*+,./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"],this.charsets.sequence=[..."Hello World!"],this.charsets.default=["1"],this.charsets.tmark=["|","#"],this.converter=new l(10,0,0),this.hasSignedMode=!0,this.littleEndian=!0,this.signed=!0,this.isMutable.signed=!0,this.isMutable.upper=!0,this.utils.validateArgs(t,!0)}encode(t,...e){const s=this.utils.validateArgs(e);let i,r;[i,r]=this.utils.inputHandler.toBytes(t,s);let n=this.converter.encode(i,null,s.littleEndian)[0],o=BigInt(n);if(o>Number.MAX_SAFE_INTEGER)throw new RangeError("Invalid string length.");o>16777216&&console.warn("The string length is really long. The JavaScript engine may have memory issues generating the output string."),o=Number(o);const a=this.charsets[s.version],l=a.length;let h="";if(1===l)h=a.at(0).repeat(o);else if("all"===s.version)for(let t=0;t<o;t++){h+=a[Math.floor(Math.random()*l)]}else if("tmark"===s.version){const t=o%5;o>4&&(h=a.at(1).repeat((o-t)/5)),h+=a.at(0).repeat(t)}else for(let t=0;t<o;t++)h+=a[t%l];return h=this.utils.toSignedStr(h,r),s.upper&&(h=h.toUpperCase()),h}decode(t,...e){const s=this.utils.validateArgs(e);let i;if(t=String(t),[t,i]=this.utils.extractSign(t),"all"!==s.version){const e=[...new Set(this.charsets[s.version])].join(""),i=new RegExp(`[^${e}]`,"g");t=t.replace(i,"")}t=String(t.length);const r=this.converter.decode(t,[..."0123456789"],[],s.integrity,s.littleEndian);return this.utils.outputHandler.compile(r,s.outputType,s.littleEndian,i)}}class u extends h{constructor(...t){super(),this.converter=new l(16,1,2),this.charsets.default=[..."0123456789abcdef"],this.padChars.default="",this.hasSignedMode=!0,this.isMutable.signed=!0,this.isMutable.upper=!0,this.utils.validateArgs(t,!0)}encode(t,...e){return super.encode(t,null,null,...e)}decode(t,...e){return super.decode(t,(t=>{let{input:e}=t;return e=e.replace(/^0x/,""),e.length%2&&(e="0".concat(e)),e}),null,...e)}}class d extends h{constructor(...t){super(),this.charsets.crockford=[..."0123456789abcdefghjkmnpqrstvwxyz"],this.padChars.crockford="=",this.charsets.rfc3548=[..."abcdefghijklmnopqrstuvwxyz234567"],this.padChars.rfc3548="=",this.charsets.rfc4648=[..."0123456789abcdefghijklmnopqrstuv"],this.padChars.rfc4648="=",this.charsets.zbase32=[..."ybndrfg8ejkmcpqxot1uwisza345h769"],this.padChars.zbase32="=",this.converter=new l(32,5,8),this.hasSignedMode=!0,this.version="rfc4648",this.isMutable.littleEndian=!0,this.isMutable.padding=!0,this.isMutable.signed=!0,this.isMutable.upper=!0,this.utils.validateArgs(t,!0),this.padding=/rfc3548|rfc4648/.test(this.version),this.upper="crockford"===this.version}encode(t,...e){return super.encode(t,null,(t=>{let{output:e,settings:s,zeroPadding:i}=t;if(!s.littleEndian&&i){const t=this.converter.padBytes(i);e=e.slice(0,e.length-t),s.padding&&(e=e.concat(this.padChars[s.version].repeat(t)))}return e}),...e)}decode(t,...e){return super.decode(t,null,null,...e)}}class p extends h{constructor(...t){super(),this.charsets.default=[..."123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],this.padChars.default=this.charsets.default[0],this.charsets.bitcoin=[..."123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],this.padChars.bitcoin=this.charsets.bitcoin[0],this.charsets.flickr=[..."123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],this.padChars.flickr=this.charsets.flickr[0],this.converter=new l(58,0,0),this.padding=!0,this.version="bitcoin",this.isMutable.padding=!0,this.isMutable.signed=!0,this.utils.validateArgs(t,!0)}encode(t,...e){return super.encode(t,null,(t=>{let{inputBytes:e,output:s,settings:i,type:r}=t;if(i.padding&&"int"!==r){let t=0;const r=e.length,n=this.charsets[i.version].at(0);if(r){for(;!e[t];)if(t++,t===r){t=0;break}const i=t;i&&(s=n.repeat(i).concat(s))}}return s}),...e)}decode(t,...e){return super.decode(t,null,(t=>{let{input:e,output:s,settings:i}=t;const r=this.charsets[i.version].at(0);if(i.padding&&e.length>1){let t=0;for(;e[t]===r;)t++;const i=t;i&&(s=Uint8Array.from([...new Array(i).fill(0),...s]))}return s}),...e)}}class f extends h{constructor(...t){super(),this.charsets.default=[..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],this.padChars.default="=",this.charsets.urlsafe=this.charsets.default.slice(0,-2).concat(["-","_"]),this.padChars.urlsafe="=",this.converter=new l(64,3,4),this.padding=!0,this.isMutable.padding=!0,this.utils.validateArgs(t,!0)}encode(t,...e){return super.encode(t,null,(t=>{let{output:e,settings:s,zeroPadding:i}=t;if(i){const t=this.converter.padBytes(i);e=e.slice(0,e.length-t),s.padding&&(e=e.concat(this.padChars[s.version].repeat(t)))}return e}),...e)}decode(t,...e){return super.decode(t,null,null,...e)}}class g extends h{constructor(...t){super(),this.charsets.adobe=[..."!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstu"],this.charsets.ascii85=this.charsets.adobe.slice(),this.charsets.rfc1924=[..."0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$%&()*+-;<=>?@^_`{|}~"],this.charsets.z85=[..."0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-:+=^!/*?&<>()[]{}@%$#"];for(const t in this.charsets)this.padChars[t]="";this.converter=new l(85,4,5,84),this.version="ascii85",this.utils.validateArgs(t,!0)}encode(t,...e){return super.encode(t,(t=>{let e;return t.version.match(/adobe|ascii85/)&&(e=(t,e)=>e||"!!!!!"!==t?t:"z"),e}),(t=>{let{output:e,settings:s,zeroPadding:i}=t;if(i){const t=this.converter.padBytes(i);e=e.slice(0,e.length-t)}return"adobe"===s.version&&(e=`<~${e}~>`),e}),...e)}decode(t,...e){return super.decode(t,(t=>{let{input:e,settings:s}=t;return s.version.match(/adobe|ascii85/)&&(e=e.replace(/z/g,"!!!!!"),"adobe"===s.version&&(e=e.replace(/^<~|~>$/g,""))),e}),null,...e)}}class y extends h{constructor(...t){super(),this.charsets.default=[...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,./:;<=>?@[]^_`{|}~"'],this.utils.validateArgs(t,!0)}encode(t,...e){const s=this.utils.validateArgs(e),i=this.utils.inputHandler.toBytes(t,s)[0];let r=0,n=0,o="";const a=this.charsets[s.version];if(i.forEach((t=>{if(n+=t<<r,r+=8,r>13){let t,e,s=13,i=n%8192;i<89&&(s=14,i=n%16384),n>>=s,r-=s,[t,e]=this.divmod(i,91),o=`${o}${a[e]}${a[t]}`}})),r){let t,e;[t,e]=this.divmod(n,91),o=o.concat(a[e]),(r>7||n>90)&&(o=o.concat(a[t]))}return o}decode(t,...e){const s=this.utils.validateArgs(e);let i=(t=String(t)).length,r=!1;i%2&&(r=!0,i--);let n=0,o=0;const a=this.charsets[s.version],l=new Array;for(let e=0;e<i;e+=2){const s=a.indexOf(t[e])+91*a.indexOf(t[e+1]);n=(s<<o)+n,o+=s%8192>88?13:14;do{l.push(n%256),n>>=8,o-=8}while(o>7)}if(r){const e=t.charAt(i),s=a.indexOf(e);l.push(((s<<o)+n)%256)}const h=Uint8Array.from(l);return this.utils.outputHandler.compile(h,s.outputType)}divmod(t,e){return[Math.floor(t/e),t%e]}}class b{constructor(...t){this.littleEndian=!0,this.numberMode=!1,this.outputType="buffer",this.utils={validateArgs:(t,e=!1)=>{const s={littleEndian:this.littleEndian,numberMode:this.numberMode,outputType:this.outputType,signed:!1};if(!t.length)return s;t.includes("number")&&(t.splice(t.indexOf("number"),1),s.numberMode=!0,s.outputType="float_n");const r=i.typeList.map((t=>`'${t}'`)).join(", ");if(t.forEach((t=>{if("le"===(t=String(t).toLowerCase()))s.littleEndian=!0;else if("be"===t)s.littleEndian=!1;else{if(!i.typeList.includes(t))throw new TypeError(`Invalid argument: '${t}.\nValid arguments are:\n'le', 'be', ${r}`);s.outputType=t}})),e)for(const t in s)this[t]=s[t];return s}},this.utils.validateArgs(t,!0)}encode(t,...e){const i=this.utils.validateArgs(e);return s.toBytes(t,i)[0]}decode(t,...e){const s=this.utils.validateArgs(e);return i.compile(t,s.outputType,s.littleEndian)}}class w extends h{#e={};#s=null;constructor(...t){super(),this.charsets.emojis_v1=[..."🀄🃏🅰🅱🅾🅿🆎🆑🆒🆓🆔🆕🆖🆗🆘🆙🆚🇦🇧🇨🇩🇪🇫🇬🇭🇮🇯🇰🇱🇲🇳🇴🇵🇶🇷🇸🇹🇺🇻🇼🇽🇾🇿🈁🈂🈚🈯🈲🈳🈴🈵🈶🈷🈸🈹🈺🉐🉑🌀🌁🌂🌃🌄🌅🌆🌇🌈🌉🌊🌋🌌🌍🌎🌏🌐🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜🌝🌞🌟🌠🌡🌤🌥🌦🌧🌨🌩🌪🌫🌬🌭🌮🌯🌰🌱🌲🌳🌴🌵🌶🌷🌸🌹🌺🌻🌼🌽🌾🌿🍀🍁🍂🍃🍄🍅🍆🍇🍈🍉🍊🍋🍌🍍🍎🍏🍐🍑🍒🍓🍔🍕🍖🍗🍘🍙🍚🍛🍜🍝🍞🍟🍠🍡🍢🍣🍤🍥🍦🍧🍨🍩🍪🍫🍬🍭🍮🍯🍰🍱🍲🍳🍴🍵🍶🍷🍸🍹🍺🍻🍼🍽🍾🍿🎀🎁🎂🎃🎄🎅🎆🎇🎈🎉🎊🎋🎌🎍🎎🎏🎐🎑🎒🎓🎖🎗🎙🎚🎛🎞🎟🎠🎡🎢🎣🎤🎥🎦🎧🎨🎩🎪🎫🎬🎭🎮🎯🎰🎱🎲🎳🎴🎵🎶🎷🎸🎹🎺🎻🎼🎽🎾🎿🏀🏁🏂🏃🏄🏅🏆🏇🏈🏉🏊🏋🏌🏎🏏🏐🏑🏒🏓🏔🏕🏖🏗🏘🏙🏚🏛🏜🏝🏞🏟🏠🏡🏢🏣🏤🏥🏦🏧🏨🏩🏪🏫🏬🏭🏮🏯🏰🏳🏴🏵🏷🏸🏹🏺🏻🏼🏽🏾🏿🐀🐁🐂🐃🐄🐅🐆🐇🐈🐉🐊🐋🐌🐍🐎🐏🐐🐑🐒🐓🐔🐕🐖🐗🐘🐙🐚🐛🐜🐝🐞🐟🐠🐡🐢🐣🐤🐥🐦🐧🐨🐩🐪🐫🐬🐭🐮🐯🐰🐱🐲🐳🐴🐵🐶🐷🐸🐹🐺🐻🐼🐽🐾🐿👀👁👂👃👄👅👆👇👈👉👊👋👌👍👎👏👐👑👒👓👔👕👖👗👘👙👚👛👜👝👞👟👠👡👢👣👤👥👦👧👨👩👪👫👬👭👮👯👰👱👲👳👴👵👶👷👸👹👺👻👼👽👾👿💀💁💂💃💄💅💆💇💈💉💊💋💌💍💎💏💐💑💒💓💔💕💖💗💘💙💚💛💜💝💞💟💠💡💢💣💤💥💦💧💨💩💪💫💬💭💮💯💰💱💲💳💴💵💶💷💸💹💺💻💼💽💾💿📀📁📂📃📄📅📆📇📈📉📊📋📌📍📎📏📐📒📓📔📕📖📗📘📙📚📛📜📝📞📟📠📡📢📣📤📥📦📧📨📩📪📫📬📭📮📯📰📱📲📳📴📵📶📷📸📹📺📻📼📽📿🔀🔁🔂🔃🔄🔅🔆🔇🔈🔉🔊🔋🔌🔍🔎🔏🔐🔑🔒🔓🔔🔕🔖🔗🔘🔙🔚🔛🔜🔝🔞🔟🔠🔡🔢🔣🔤🔥🔦🔧🔨🔩🔪🔫🔬🔭🔮🔯🔰🔱🔲🔳🔴🔵🔶🔷🔸🔹🔺🔻🔼🔽🕉🕊🕋🕌🕍🕎🕐🕑🕒🕓🕔🕕🕖🕗🕘🕙🕚🕛🕜🕝🕞🕟🕠🕡🕢🕣🕤🕥🕦🕧🕯🕰🕳🕴🕵🕶🕷🕸🕹🕺🖇🖊🖋🖌🖍🖐🖕🖖🖤🖥🖨🖱🖲🖼🗂🗃🗄🗑🗒🗓🗜🗝🗞🗡🗣🗨🗯🗳🗺🗻🗼🗽🗾🗿😀😁😂😃😄😅😆😇😈😉😊😋😌😍😎😏😐😑😒😓😔😕😖😗😘😙😚😛😜😝😞😟😠😡😢😣😤😥😦😧😨😩😪😫😬😭😮😯😰😱😲😳😴😵😶😷😸😹😺😻😼😽😾😿🙀🙁🙂🙃🙄🙅🙆🙇🙈🙉🙊🙌🙍🙎🙏🚀🚁🚂🚃🚄🚅🚆🚇🚈🚉🚊🚋🚌🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚙🚚🚛🚜🚝🚞🚟🚠🚡🚢🚣🚤🚥🚦🚧🚨🚩🚪🚫🚬🚭🚮🚯🚰🚱🚲🚳🚴🚵🚶🚷🚸🚹🚺🚻🚼🚽🚾🚿🛀🛁🛂🛃🛄🛅🛋🛌🛍🛎🛏🛐🛑🛒🛠🛡🛢🛣🛤🛥🛩🛫🛬🛰🛳🛴🛵🛶🛷🛸🛹🤐🤑🤒🤓🤔🤕🤖🤗🤘🤙🤚🤛🤜🤝🤞🤟🤠🤡🤢🤣🤤🤥🤦🤧🤨🤩🤪🤫🤬🤭🤮🤯🤰🤱🤲🤳🤴🤵🤶🤷🤸🤹🤺🤼🤽🤾🥀🥁🥂🥃🥄🥅🥇🥈🥉🥊🥋🥌🥍🥎🥏🥐🥑🥒🥓🥔🥕🥖🥗🥘🥙🥚🥛🥜🥝🥞🥟🥠🥡🥢🥣🥤🥥🥦🥧🥨🥩🥪🥫🥬🥭🥮🥯🥰🥳🥴🥵🥶🥺🥼🥽🥾🥿🦀🦁🦂🦃🦄🦅🦆🦇🦈🦉🦊🦋🦌🦍🦎🦏🦐🦑🦒🦓🦔🦕🦖🦗🦘🦙🦚🦛🦜🦝🦞🦟🦠🦡🦢🦰🦱🦲🦳🦴🦵🦶🦷🦸🦹🧀🧁🧂🧐🧑🧒🧓🧔🧕"],this.padChars.emojis_v1=["⚜","🏍","📑","🙋","☕"],this.charsets.emojis_v2=[..."🀄🃏⏰⏳☔♈♉♊♋♌♍♎♏♐♑♒♓♿⚓⚡⚽⚾⛄⛅⛎⛔⛪⛲⛳⛵⛺⛽✊✋✨⭐🛕🛖🛗🛝🛞🛟🛺🈁🛻🤌🤏🤿🥱🥲🥸🥹🥻🦣🦤🦥🦦🦧🌀🌁🌂🌃🌄🌅🌆🌇🌈🌉🌊🌋🌌🌍🌎🌏🌐🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜🌝🌞🌟🌠🦨🦩🦪🦫🦬🦭🦮🦯🦺🦻🌭🌮🌯🌰🌱🌲🌳🌴🌵🦼🌷🌸🌹🌺🌻🌼🌽🌾🌿🍀🍁🍂🍃🍄🍅🍆🍇🍈🍉🍊🍋🍌🍍🍎🍏🍐🍑🍒🍓🍔🍕🍖🍗🍘🍙🍚🍛🍜🍝🍞🍟🍠🍡🍢🍣🍤🍥🍦🍧🍨🍩🍪🍫🍬🍭🍮🍯🍰🍱🍲🍳🍴🍵🍶🍷🍸🍹🍺🍻🍼🦽🍾🍿🎀🎁🎂🎃🎄🎅🎆🎇🎈🎉🎊🎋🎌🎍🎎🎏🎐🎑🎒🎓🦾🦿🧃🧄🧅🧆🧇🎠🎡🎢🎣🎤🎥🧈🎧🎨🎩🎪🎫🎬🎭🎮🎯🎰🎱🎲🎳🎴🎵🎶🎷🎸🎹🎺🎻🎼🎽🎾🎿🏀🏁🏂🏃🏄🏅🏆🏇🏈🏉🏊🧉🧊🧋🏏🏐🏑🏒🏓🧌🧍🧎🧏🧖🧗🧘🧙🧚🧛🧜🧝🏠🏡🏢🏣🏤🏥🏦🧞🏨🏩🏪🏫🏬🏭🏮🏯🏰🧟🏴🧠🧢🏸🏹🏺🧣🧤🧥🧦🧧🐀🐁🐂🐃🐄🐅🐆🐇🐈🐉🐊🐋🐌🐍🐎🐏🐐🐑🐒🐓🐔🐕🐖🐗🐘🐙🐚🐛🐜🐝🐞🐟🐠🐡🐢🐣🐤🐥🐦🐧🐨🐩🐪🐫🐬🐭🐮🐯🐰🐱🐲🐳🐴🐵🐶🐷🐸🐹🐺🐻🐼🐽🐾🧨👀🧩👂👃👄👅👆👇👈👉👊👋👌👍👎👏👐👑👒👓👔👕👖👗👘👙👚👛👜👝👞👟👠👡👢👣👤👥👦👧👨👩👪👫👬👭👮👯👰👱👲👳👴👵👶👷👸👹👺👻👼👽👾👿💀💁💂💃💄💅💆💇💈💉💊💋💌💍💎💏💐💑💒💓💔💕💖💗💘💙💚💛💜💝💞💟💠💡💢💣💤💥💦💧💨💩💪💫💬💭💮💯💰💱💲💳💴💵💶💷💸🧪💺💻💼💽💾💿📀🧫📂📃📄🧬📆📇📈📉📊📋📌📍📎📏📐📒📓📔📕📖📗📘📙📚📛📜📝📞📟📠📡📢📣📤📥📦📧📨📩📪📫📬📭📮📯📰📱📲📳🧭📵📶📷📸📹📺📻📼🧮📿🧯🧰🧱🧲🧳🔅🔆🔇🔈🔉🔊🔋🔌🔍🔎🔏🔐🔑🔒🔓🔔🔕🔖🔗🔘🧴🧵🧶🧷🧸🧹🧺🧻🧼🧽🧾🧿🔥🔦🔧🔨🔩🔪🔫🔬🔭🔮🔯🔰🔱🔲🔳🩰🩱🩲🩳🩴🩸🩹🩺🩻🩼🪀🪁🕋🕌🕍🕎🪂🪃🪄🪅🪆🪐🪑🪒🪓🪔🪕🪖🪗🪘🪙🪚🪛🪜🪝🪞🪟🪠🪡🪢🪣🪤🪥🪦🪧🪨🪩🪪🪫🕺🪬🪰🪱🪲🪳🪴🖕🖖🖤🪵🪶🪷🪸🪹🪺🫀🫁🫂🫃🫄🫅🫐🫑🫒🫓🫔🫕🫖🫗🗻🗼🗽🗾🗿😀😁😂😃😄😅😆😇😈😉😊😋😌😍😎😏😐😑😒😓😔😕😖😗😘😙😚😛😜😝😞😟😠😡😢😣😤😥😦😧😨😩😪😫😬😭😮😯😰😱😲😳😴😵😶😷😸😹😺😻😼😽😾😿🙀🙁🙂🙃🙄🙅🙆🙇🙈🙉🙊🙌🙍🙎🙏🚀🚁🚂🚃🚄🚅🚆🚇🚈🚉🚊🚋🚌🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚙🚚🚛🚜🚝🚞🚟🚠🚡🚢🚣🚤🚥🚦🚧🚨🚩🚪🚫🚬🚭🚮🚯🚰🚱🚲🚳🚴🚵🚶🚷🚸🚹🚺🚻🚼🚽🚾🚿🛀🛁🛂🛃🛄🛅🫘🛌🫙🫠🫡🛐🛑🛒🫢🫣🫤🫥🫦🫧🫰🛫🛬🫱🫲🛴🛵🛶🛷🛸🛹🤐🤑🤒🤓🤔🤕🤖🤗🤘🤙🤚🤛🤜🤝🤞🤟🤠🤡🤢🤣🤤🤥🤦🤧🤨🤩🤪🤫🤬🤭🤮🤯🤰🤱🤲🤳🤴🤵🤶🤷🤸🤹🤺🤼🤽🤾🥀🥁🥂🥃🥄🥅🥇🥈🥉🥊🥋🥌🥍🥎🥏🥐🥑🥒🥓🥔🥕🥖🥗🥘🥙🥚🥛🥜🥝🥞🥟🥠🥡🥢🥣🥤🥥🥦🥧🥨🥩🥪🥫🥬🥭🥮🥯🥰🥳🥴🥵🥶🥺🥼🥽🥾🥿🦀🦁🦂🦃🦄🦅🦆🦇🦈🦉🦊🦋🦌🦍🦎🦏🦐🦑🦒🦓🦔🦕🦖🦗🦘🦙🦚🦛🦜🦝🦞🦟🦠🦡🦢🫳🫴🫵🫶🦴🦵🦶🦷🦸🦹🧀🧁🧂🧐🧑🧒🧓🧔🧕"],this.padChars.emojis_v2=["🥷","🛼","📑","🙋","☕"],this.#i(),this.converter=new l(1024,5,4),this.padding=!0,this.version="emojis_v1",this.isMutable.padding=!0,this.isMutable.trim=!0,this.trim=null,this.utils.converterArgs.trim=["notrim","trim"],this.utils.validateArgs(t,!0),null===this.trim&&(this.trim="emojis_v2"===this.version)}#i(){const t={},e=(t,e)=>{e.forEach((e=>{e in this.#e?this.#e[e].version+=t:this.#e[e]={version:t}}))},s=(e,s,i)=>{s.forEach((s=>{s in t?this.#e[s].version=3:(this.#e[s]={version:e,padding:i},t[s]=i)}))};e(1,this.charsets.emojis_v1),e(2,this.charsets.emojis_v2),s(1,this.padChars.emojis_v1.slice(0,-1),"last"),s(2,this.padChars.emojis_v2.slice(0,-1),"last"),s(1,this.padChars.emojis_v1.slice(-1),"fill"),s(2,this.padChars.emojis_v2.slice(-1),"fill");const i=[];for(const e in t)"last"===t[e]?i.push(e):i.push(`${e}+`);this.#s=new RegExp(i.join("|"),"g")}encode(t,...e){return super.encode(t,null,(t=>{let{output:e,settings:s,zeroPadding:i}=t;const r=this.charsets[s.version];let n=[...e];if(i>1){const t=this.converter.padBytes(i);if(s.padding){const e=s.trim?1:t,i=new Array(e).fill(this.padChars[s.version].at(-1));n.splice(n.length-t,t,...i)}else n.splice(n.length-t,t)}else if(1===i){const t=r.indexOf(n.pop())>>8;n.push(this.padChars[s.version].at(t))}return n.join("")}),...e)}decode(t,...e){const s=this.utils.validateArgs(e);t=String(t);let i=3;const r=t=>{i=this.#r(t,i,s.integrity);const e=3===i?s.version:`emojis_v${i}`,r=this.charsets[e],n=[...t],o=n.at(-1);let a=!1;for(let s=0;s<this.padChars[e].length-1;s++)if(o===this.padChars[e].at(s)){n.splice(-1,1,r.at(s<<8)),t=n.join(""),a=!0;break}let l=this.converter.decode(t,this.charsets[e],[],!1);return a&&(l=new Uint8Array(l.buffer.slice(0,-1))),l},n=[...t.matchAll(this.#s)];let o;if(n.length<2)o=r(t);else{const e=[];let s=0;n.forEach((i=>{const n=i.index+i.at(0).length;e.push(...r(t.slice(s,n))),s=n})),s!==t.length&&e.push(...r(t.slice(s,t.length))),o=Uint8Array.from(e)}return this.utils.outputHandler.compile(o,s.outputType)}#r(t,e,s){const i=[...t];let r;if(i.forEach(((t,i)=>{if(!(t in this.#e))throw new TypeError(`Non Ecoji character seen : ${t}`);{const n=this.#e[t].version;if(3!==n)if(3===e)e=n;else if(e!==n)throw new TypeError(`Emojis from different ecoji versions seen : ${t} from emojis_v${n}`);if(s){const e=this.#e[t].padding;if(e){const s=i%4;if(r=!0,"fill"===e){if(0===s)throw new TypeError(`Padding unexpectedly seen in first position ${t}`)}else if(3!==s)throw new TypeError(`Last padding seen in unexpected position ${t}`)}else if(r)throw new TypeError("Unexpectedly saw non-padding after padding")}}})),s&&i.length%4&&(1===e||"fill"!==this.#e[i.at(-1)].padding))throw new TypeError("Unexpected end of data, input data size not multiple of 4");return e}}class v extends h{constructor(...t){super(!1),this.charsets.default="<placeholder>",this.padChars.default="",this.charsets.hex="<placeholder>",this.padChars.hex="",this.version="default",this.converter=new l(10,0,0),this.hexlify=new l(16,1,2),this.utils=new a(this,!1),this.littleEndian=!0,this.hasSignedMode=!0,this.isMutable.signed=!0,this.utils.validateArgs(t,!0)}encode(t,...e){const s=this.utils.validateArgs(e);let i,r;const n=s.signed;s.signed=!0,[i,r]=this.utils.inputHandler.toBytes(t,s);let o=this.converter.encode(i,null,s.littleEndian)[0],a=BigInt(o),l=new Array;if(r){if(!n)throw new TypeError("Negative values in unsigned mode are invalid.");a=-a}if(n)for(;;){const t=Number(127n&a);if(a>>=7n,0==a&&0==(64&t)||-1==a&&0!=(64&t)){l.push(t);break}l.push(128|t)}else for(;;){const t=Number(127n&a);if(a>>=7n,0==a){l.push(t);break}l.push(128|t)}const h=Uint8Array.from(l);return"hex"===s.version?this.hexlify.encode(h,[..."0123456789abcdef"],!1)[0]:h}decode(t,...e){const s=this.utils.validateArgs(e);if("hex"===s.version?t=this.hexlify.decode(String(t).toLowerCase(),[..."0123456789abcdef"],"",s.integrity,!1):t instanceof ArrayBuffer&&(t=new Uint8Array(t)),1===t.length&&!t[0])return this.utils.outputHandler.compile(new Uint8Array(1),s.outputType,!0);t=Array.from(t);let i,r,n,o=0n,a=-7n;for(i of t)a+=7n,o+=BigInt(127&i)<<a;s.signed&&0!=(64&i)&&(o|=-(1n<<a+7n)),[r,n]=this.utils.extractSign(o.toString());const l=this.converter.decode(r,[..."0123456789"],[],s.integrity,!0);return this.utils.outputHandler.compile(l,s.outputType,!0,n)}}class m extends h{constructor(t,...e){if(super(),!t||!Number.isInteger(t)||t<2||t>36)throw new RangeError("Radix argument must be provided and has to be an integer between 2 and 36.");this.charsets.default=[..."0123456789abcdefghijklmnopqrstuvwxyz"].slice(0,t),this.converter=new l(t,0,0),this.hasSignedMode=!0,this.littleEndian=!(2===t||16===t),this.signed=!0,this.version="default",this.isMutable.littleEndian=!0,this.isMutable.upper=!0,this.utils.validateArgs(e,!0)}encode(t,...e){return super.encode(t,null,null,...e)}decode(t,...e){return super.decode(t,(t=>{let{input:e}=t;if(2===this.converter.radix){const t=(8-e.length%8)%8;e=`${"0".repeat(t)}${e}`}else if(16===this.converter.radix){const t=e.length%2;e=`${"0".repeat(t)}${e}`}return e}),null,...e)}}
/**
 * [BaseEx]{@link https://github.com/UmamiAppearance/BaseExJS}
 *
 * @version 0.5.0
 * @author UmamiAppearance [mail@umamiappearance.eu]
 * @license GPL-3.0 AND BSD-3-Clause (only regarding Base91, Copyright (c) 2000-2006 Joachim Henke)
 */class A{constructor(t="buffer"){if(!n.typeList.includes(t)){let e=`Invalid argument '${t}' for output type. Allowed types are:\n`;throw e=e.concat(n.typeList.join(", ")),new TypeError(e)}this.base1=new c("default",t),this.base16=new u("default",t),this.base32_crockford=new d("rfc4648",t),this.base32_rfc3548=new d("rfc3548",t),this.base32_rfc4648=new d("rfc4648",t),this.base32_zbase32=new d("zbase32",t),this.base58=new p("default",t),this.base58_bitcoin=new p("bitcoin",t),this.base58_flickr=new p("flickr",t),this.base64=new f("default",t),this.base64_urlsafe=new f("urlsafe",t),this.base85_adobe=new g("adobe",t),this.base85_ascii=new g("ascii85",t),this.base85_z85=new g("z85",t),this.base91=new y("default",t),this.leb128=new v("default",t),this.ecoji_v1=new w("emojis_v1"),this.ecoji_v2=new w("emojis_v2"),this.byteConverter=new b(t),this.simpleBase={};for(let e=2;e<37;e++)this.simpleBase[`base${e}`]=new m(e,t)}}export{c as Base1,u as Base16,d as Base32,p as Base58,f as Base64,g as Base85,y as Base91,A as BaseEx,b as ByteConverter,w as Ecoji,v as LEB128,m as SimpleBase};
