class BytesInput{static toBytes(t){return ArrayBuffer.isView(t)&&(t=t.buffer),[new Uint8Array(t),!1,"bytes"]}}class BytesOutput{static get typeList(){return["buffer","bytes","uint8","view"]}static getType(t){if(!BytesOutput.typeList.includes(t))throw new TypeError(`Unknown output type: '${t}'`);return t}static compile(t,e){let r;return r="buffer"===(e=BytesOutput.getType(e))?t.buffer:"view"===e?new DataView(t.buffer):t,r}}class SmartInput{static makeDataView(t){const e=new ArrayBuffer(t);return new DataView(e)}static floatingPoints(t,e=!1){const r=this.makeDataView(8);return r.setFloat64(0,t,e),r}static numbers(t,e=!1){let r,n;if(Number.isInteger(t)){if(n="int",!Number.isSafeInteger(t)){let e,r,n;throw t<0?(e=Number.MIN_SAFE_INTEGER,r="smaller",n="MIN"):(e=Number.MAX_SAFE_INTEGER,r="bigger",n="MAX"),new RangeError(`The provided integer is ${r} than ${n}_SAFE_INTEGER: '${e}'\nData integrity is not guaranteed. Use a BigInt to avoid this issue.\n(If you see this error although a float was provided, the input has to many digits before the decimal point to store the decimal places in a float with 64 bits.)`)}t<0?t<-2147483648?(r=this.makeDataView(8),r.setBigInt64(0,BigInt(t),e)):t<-32768?(r=this.makeDataView(4),r.setInt32(0,t,e)):(r=this.makeDataView(2),r.setInt16(0,t,e)):t>0?t>4294967295?(r=this.makeDataView(8),r.setBigUint64(0,BigInt(t),e)):t>65535?(r=this.makeDataView(4),r.setUint32(0,t,e)):(r=this.makeDataView(2),r.setInt16(0,t,e)):r=new Uint16Array([0])}else n="float",r=this.floatingPoints(t,e);return[new Uint8Array(r.buffer),n]}static bigInts(t,e=!1){const r=new Array,n=e?"push":"unshift",i=18446744073709551616n;if(t<0)for(;t<-9223372036854775808n;)r[n](t%i),t>>=64n;else for(;t>=i;)r[n](t%i),t>>=64n;r[n](t);const s=8*r.length,o=this.makeDataView(s);return r.forEach(((t,r)=>{const n=8*r;o.setBigUint64(n,t,e)})),new Uint8Array(o.buffer)}static toBytes(t,e){let r,n=!1,i="bytes";if(t instanceof ArrayBuffer)r=new Uint8Array(t.slice());else if(ArrayBuffer.isView(t))r=new Uint8Array(t.buffer.slice());else if("string"==typeof t||t instanceof String)r=(new TextEncoder).encode(t);else if("number"==typeof t){if(isNaN(t))throw new TypeError("Cannot proceed. Input is NaN.");if(t==1/0)throw new TypeError("Cannot proceed. Input is Infinity.");if(e.signed&&t<0&&(n=!0,t=-t),e.numberMode){const n=this.floatingPoints(t,e.littleEndian);r=new Uint8Array(n.buffer),i="float"}else[r,i]=this.numbers(t,e.littleEndian)}else if("bigint"==typeof t)e.signed&&t<0&&(n=!0,t*=-1n),r=this.bigInts(t,e.littleEndian),i="int";else{if(!Array.isArray(t))throw new TypeError("The provided input type can not be processed.");{const n=new Array;for(const r of t)n.push(...this.toBytes(r,e)[0]);r=Uint8Array.from(n)}}return[r,n,i]}}class SmartOutput{static get typeList(){return["bigint64","bigint_n","biguint64","buffer","bytes","float32","float64","float_n","int8","int16","int32","int_n","str","uint8","uint16","uint32","uint_n","view"]}static getType(t){if(!this.typeList.includes(t))throw new TypeError(`Unknown output type: '${t}'`);return t}static makeTypedArrayBuffer(t,e,r,n){const i=t.byteLength,s=(e-t.byteLength%e)%e,o=n&&i>1?255:0;let a=t;if(s){a=new Uint8Array(i+s),a.fill(o);const e=r?0:s;a.set(t,e)}return a.buffer}static makeTypedArray(t,e,r,n){let i;if("int16"===e||"uint16"===e){const s=this.makeTypedArrayBuffer(t,2,r,n);i="int16"===e?new Int16Array(s):new Uint16Array(s)}else if("int32"===e||"uint32"===e||"float32"===e){const s=this.makeTypedArrayBuffer(t,4,r,n);i="int32"===e?new Int32Array(s):"uint32"===e?new Uint32Array(s):new Float32Array(s)}else if("bigint64"===e||"biguint64"===e||"float64"===e){const s=this.makeTypedArrayBuffer(t,8,r,n);i="bigint64"===e?new BigInt64Array(s):"biguint64"===e?new BigUint64Array(s):new Float64Array(s)}return i}static compile(t,e,r=!1,n=!1){let i;if(e=this.getType(e),n){let n;if(n=e.match(/^float/)?-this.compile(t,"float_n",r):-this.compile(t,"uint_n",r),"float_n"===e)return n;t=SmartInput.toBytes(n,{littleEndian:r,numberMode:!1,signed:!1})[0]}if("buffer"===e)i=t.buffer;else if("bytes"===e||"uint8"===e)i=t;else if("int8"===e)i=new Int8Array(t.buffer);else if("view"===e)i=new DataView(t.buffer);else if("str"===e)i=(new TextDecoder).decode(t);else if("uint_n"===e||"int_n"===e||"bigint_n"===e){if(1===t.length){const e=this.makeTypedArrayBuffer(t,2,r,n);t=new Uint8Array(e)}r&&t.reverse();let s=0n;t.forEach((t=>s=(s<<8n)+BigInt(t))),"uint_n"!==e&&(s=BigInt.asIntN(8*t.length,s)),i="bigint_n"!==e&&s>=Number.MIN_SAFE_INTEGER&&s<=Number.MAX_SAFE_INTEGER?Number(s):s}else if("float_n"===e)if(t.length<=4){let e;e=4===t.length?t:this.makeTypedArray(t,"float32",!1,n);i=new DataView(e.buffer).getFloat32(0,r)}else{if(!(t.length<=8))throw new RangeError("The provided input is to complex to be converted into a floating point.");{let e;e=8===t.length?t:this.makeTypedArray(t,"float64",!1,n);i=new DataView(e.buffer).getFloat64(0,r)}}else if("number"===e){if(8!==t.length)throw new TypeError("Type mismatch. Cannot convert into number.");const e=new Float64Array(t.buffer);i=Number(e)}else i=this.makeTypedArray(t,e,r,n);return i}}const DEFAULT_INPUT_HANDLER=SmartInput,DEFAULT_OUTPUT_HANDLER=SmartOutput;class SignError extends TypeError{constructor(){super("The input is signed but the converter is not set to treat input as signed.\nYou can pass the string 'signed' to the decode function or when constructing the converter."),this.name="SignError"}}class CharsetError extends TypeError{constructor(t){super(`Invalid input. Character: '${t}' is not part of the charset.`),this.name="CharsetError"}}class Utils{constructor(t){this.root=t,this.converterArgs={},this.#t()}setIOHandlers(t=DEFAULT_INPUT_HANDLER,e=DEFAULT_OUTPUT_HANDLER){this.inputHandler=t,this.outputHandler=e}#t(){this.root.addCharset=(t,e,r=[],n=!0)=>{const i=(t,r,n)=>{if(0===n&&r.length)return console.warn(`This converter has no ${t}. The following argument was ignored:\n'${r}'`),[];let i=n;if("string"==typeof r&&(r=[...r]),Array.isArray(r))i=r.length,r=new Set(r);else if(!(r instanceof Set))throw new TypeError(`The ${t} must be one of the types:\n'str', 'set', 'array'."`);if(r.size===n)return[...r];if(i!==n)throw new Error(`Your ${t} has a length of ${i}. The converter requires a length of ${n}.`);{const r={};(e=[...e]).forEach((t=>{t in r?r[t]++:r[t]=1}));let i="";n<100&&(i=`${e.join("")}\n`,e.forEach((t=>{r[t]>1?i+="^":i+=" "})));const s=Object.keys(r).filter((t=>r[t]>1));throw new Error(`You have repetitive char(s) [ ${s.join(" | ")} ] in your ${t}. Make sure each character is unique.\n${i}`)}};if(this.root.frozenCharsets)throw new Error("The charsets of this converter cannot be changed.");if("string"!=typeof t)throw new TypeError("The charset name must be a string.");n&&t in this.root.charsets&&console.warn(`An existing charset with name ${t} will get replaced.`);const s=i("charset",e,this.root.converter.radix),o=i("padding set",r,this.root.padCharAmount);this.root.charsets[t]=s,o.length&&(this.root.padChars[t]=o),n&&console.info(`New charset '${t}' was added and is ready to use`)},this.root.setDefaultCharset=t=>{if(!(t in this.root.charsets)){const e=Object.keys(this.root.charsets).join("\n   * ");throw new TypeError(`Charset ${t} was not found. Available charsets are:\n   * ${e}`)}this.root.version=t}}#e(t){return t.map((t=>`'${t}'`)).join(", ")}toSignedStr(t,e){return t=t.replace(/^0+(?!$)/,""),e&&(t="-".concat(t)),t}extractSign(t){let e=!1;return"-"===t[0]&&(e=!0,t=t.slice(1)),[t,e]}#r(t,e,r,n){const i=n?"\n * valid declarations for IO handlers are 'bytesOnly', 'bytesIn', 'bytesOut'":"",s=this.root.isMutable.signed?"\n * pass 'signed' to disable, 'unsigned' to enable the use of the twos's complement for negative integers":"",o=this.root.isMutable.littleEndian?"\n * 'be' for big , 'le' for little endian byte order for case conversion":"",a=this.root.isMutable.padding?"\n * pass 'pad' to fill up, 'nopad' to not fill up the output with the particular padding":"",h=this.root.isMutable.upper?"\n * valid args for changing the encoded output case are 'upper' and 'lower'":"",u=`\n * valid args for the output type are ${this.#e(r)}`,l=e?`\n * the option(s) for version/charset are: ${this.#e(e)}`:"",c=Object.keys(this.converterArgs).length?`\n * converter specific args:\n   - ${(()=>Object.keys(this.converterArgs).map((t=>this.converterArgs[t].map((t=>`'${t}'`)).join(" and "))).join("\n   - "))()}`:"";throw new TypeError(`'${t}'\n\nParameters:${i}${s}${o}${a}${h}${u}${l}\n * valid args for integrity check are: 'integrity' and 'nointegrity'\n * 'number' for number-mode (converts every number into a Float64Array to keep the natural js number type)${c}\n\nTraceback:`)}validateArgs(t,e=!1){const r={decimalMode:this.root.decimalMode,integrity:this.root.integrity,littleEndian:this.root.littleEndian,numberMode:this.root.numberMode,options:this.root.options,outputType:this.root.outputType,padding:this.root.padding,signed:this.root.signed,upper:this.root.upper,version:this.root.version};for(const t in this.converterArgs)r[t]=this.root[t];if(!t.length)return e&&this.setIOHandlers(),r;const n=e=>!!t.includes(e)&&(t.splice(t.indexOf(e),1),!0),i=Object.keys(this.root.charsets),s={integrity:["nointegrity","integrity"],littleEndian:["be","le"],padding:["nopad","pad"],signed:["unsigned","signed"],upper:["lower","upper"],...this.converterArgs};if(e)if(n("bytes_only"))this.setIOHandlers(BytesInput,BytesOutput);else{const t=n("bytes_in")?BytesInput:DEFAULT_INPUT_HANDLER,e=n("bytes_out")?BytesOutput:DEFAULT_OUTPUT_HANDLER;this.setIOHandlers(t,e)}const o=this.outputHandler.typeList;if(n("number")?(r.numberMode=!0,r.outputType="float_n"):n("decimal")&&(r.decimalMode=!0,r.outputType="decimal"),t.forEach((t=>{if("object"!=typeof t)if(t=String(t).toLowerCase(),i.includes(t))r.version=t;else if(o.includes(t))r.outputType=t;else{let n=!0;for(const e in s)if(s[e].includes(t)){if(n=!1,!this.root.isMutable[e])throw TypeError(`Argument '${t}' is not allowed for this type of converter.`);r[e]=Boolean(s[e].indexOf(t))}n&&this.#r(t,i,o,e)}else r.options={...r.options,...t}})),r.padding&&r.signed&&(r.padding=!1,console.warn("Padding was set to false due to the signed conversion.")),e)for(const t in r)this.root[t]=r[t];return r}signError(){throw new SignError}wrapOutput(t,e=0){if(!e)return t;const r=new RegExp(`.{1,${e}}`,"gu");return t.match(r).join("\n")}normalizeInput(t,e=!1){return e?String(t):String(t).replace(/\n/g,"")}}class BaseTemplate{constructor(t=!0){this.charsets={},this.decimalMode=!1,this.frozenCharsets=!1,this.hasSignedMode=!1,this.integrity=!0,this.littleEndian=!1,this.numberMode=!1,this.outputType="buffer",this.padding=!1,this.padCharAmount=0,this.padChars={},this.signed=!1,this.upper=null,t&&(this.utils=new Utils(this)),this.version="default",this.options={lineWrap:0},this.isMutable={integrity:!0,littleEndian:!1,padding:!1,signed:!1,upper:!1}}encode(t,e,r,...n){const i=this.utils.validateArgs(n);let[s,o,a]=this.utils.inputHandler.toBytes(t,i),h=null;e&&(h=e(i));let[u,l]=this.converter.encode(s,this.charsets[i.version],i.littleEndian,h);return i.signed&&(u=this.utils.toSignedStr(u,o)),i.upper&&(u=u.toUpperCase()),r&&(u=r({inputBytes:s,output:u,settings:i,zeroPadding:l,type:a})),this.utils.wrapOutput(u,i.options.lineWrap)}decode(t,e,r,n,...i){const s=this.utils.validateArgs(i);t=this.utils.normalizeInput(t,n);let o=!1;this.hasSignedMode&&([t,o]=this.utils.extractSign(t),o&&!s.signed&&this.utils.signError()),this.isMutable.upper&&(t=t.toLowerCase()),e&&(t=e({input:t,settings:s}));let a=this.converter.decode(t,this.charsets[s.version],this.padChars[s.version],s.integrity,s.littleEndian);return r&&(a=r({input:t,output:a,settings:s})),this.utils.outputHandler.compile(a,s.outputType,s.littleEndian,o)}}
/**
 * [BaseEx|Base2048 Converter]{@link https://github.com/UmamiAppearance/BaseExJS/src/converters/base-16.js}
 *
 * @version 0.5.0
 * @author UmamiAppearance [mail@umamiappearance.eu]
 * @license GPL-3.0
 */class Base2048 extends BaseTemplate{constructor(...t){super(),this.converter={radix:2048,bsEnc:11,bsEncPad:3,bsDec:8},this.charsets.default=[..."89ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzÆÐØÞßæðøþĐđĦħıĸŁłŊŋŒœŦŧƀƁƂƃƄƅƆƇƈƉƊƋƌƍƎƏƐƑƒƓƔƕƖƗƘƙƚƛƜƝƞƟƢƣƤƥƦƧƨƩƪƫƬƭƮƱƲƳƴƵƶƷƸƹƺƻƼƽƾƿǀǁǂǃǝǤǥǶǷȜȝȠȡȢȣȤȥȴȵȶȷȸȹȺȻȼȽȾȿɀɁɂɃɄɅɆɇɈɉɊɋɌɍɎɏɐɑɒɓɔɕɖɗɘəɚɛɜɝɞɟɠɡɢɣɤɥɦɧɨɩɪɫɬɭɮɯɰɱɲɳɴɵɶɷɸɹɺɻɼɽɾɿʀʁʂʃʄʅʆʇʈʉʊʋʌʍʎʏʐʑʒʓʔʕʖʗʘʙʚʛʜʝʞʟʠʡʢʣʤʥʦʧʨʩʪʫʬʭʮʯͰͱͲͳͶͷͻͼͽͿΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζηθικλμνξοπρςστυφχψωϏϗϘϙϚϛϜϝϞϟϠϡϢϣϤϥϦϧϨϩϪϫϬϭϮϯϳϷϸϺϻϼϽϾϿЂЄЅІЈЉЊЋЏАБВГДЕЖЗИКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзиклмнопрстуфхцчшщъыьэюяђєѕіјљњћџѠѡѢѣѤѥѦѧѨѩѪѫѬѭѮѯѰѱѲѳѴѵѸѹѺѻѼѽѾѿҀҁҊҋҌҍҎҏҐґҒғҔҕҖҗҘҙҚқҜҝҞҟҠҡҢңҤҥҦҧҨҩҪҫҬҭҮүҰұҲҳҴҵҶҷҸҹҺһҼҽҾҿӀӃӄӅӆӇӈӉӊӋӌӍӎӏӔӕӘәӠӡӨөӶӷӺӻӼӽӾӿԀԁԂԃԄԅԆԇԈԉԊԋԌԍԎԏԐԑԒԓԔԕԖԗԘԙԚԛԜԝԞԟԠԡԢԣԤԥԦԧԨԩԪԫԬԭԮԯԱԲԳԴԵԶԷԸԹԺԻԼԽԾԿՀՁՂՃՄՅՆՇՈՉՊՋՌՍՎՏՐՑՒՓՔՕՖաբգդեզէըթժիլխծկհձղճմյնշոչպջռսվտրցւփքօֆאבגדהוזחטיךכלםמןנסעףפץצקרשתװױײؠءابةتثجحخدذرزسشصضطظعغػؼؽؾؿفقكلمنهوىي٠١٢٣٤٥٦٧٨٩ٮٯٱٲٳٴٹٺٻټٽپٿڀځڂڃڄڅچڇڈډڊڋڌڍڎڏڐڑڒړڔڕږڗژڙښڛڜڝڞڟڠڡڢڣڤڥڦڧڨکڪګڬڭڮگڰڱڲڳڴڵڶڷڸڹںڻڼڽھڿہۃۄۅۆۇۈۉۊۋیۍێۏېۑےەۮۯ۰۱۲۳۴۵۶۷۸۹ۺۻۼۿܐܒܓܔܕܖܗܘܙܚܛܜܝܞܟܠܡܢܣܤܥܦܧܨܩܪܫܬܭܮܯݍݎݏݐݑݒݓݔݕݖݗݘݙݚݛݜݝݞݟݠݡݢݣݤݥݦݧݨݩݪݫݬݭݮݯݰݱݲݳݴݵݶݷݸݹݺݻݼݽݾݿހށނރބޅކއވމފދތލގޏސޑޒޓޔޕޖޗޘޙޚޛޜޝޞޟޠޡޢޣޤޥޱ߀߁߂߃߄߅߆߇߈߉ߊߋߌߍߎߏߐߑߒߓߔߕߖߗߘߙߚߛߜߝߞߟߠߡߢߣߤߥߦߧߨߩߪࠀࠁࠂࠃࠄࠅࠆࠇࠈࠉࠊࠋࠌࠍࠎࠏࠐࠑࠒࠓࠔࠕࡀࡁࡂࡃࡄࡅࡆࡇࡈࡉࡊࡋࡌࡍࡎࡏࡐࡑࡒࡓࡔࡕࡖࡗࡘࡠࡡࡢࡣࡤࡥࡦࡧࡨࡩࡪࢠࢡࢢࢣࢤࢥࢦࢧࢨࢩࢪࢫࢬࢭࢮࢯࢰࢱࢲࢳࢴࢶࢷࢸࢹࢺࢻࢼࢽऄअआइईउऊऋऌऍऎएऐऑऒओऔकखगघङचछजझञटठडढणतथदधनपफबभमयरलळवशषसहऽॐॠॡ०१२३४५६७८९ॲॳॴॵॶॷॸॹॺॻॼॽॾॿঀঅআইঈউঊঋঌএঐওঔকখগঘঙচছজঝঞটঠডঢণতথদধনপফবভমযরলশষসহঽৎৠৡ০১২৩৪৫৬৭৮৯ৰৱ৴৵৶৷৸৹ৼਅਆਇਈਉਊਏਐਓਔਕਖਗਘਙਚਛਜਝਞਟਠਡਢਣਤਥਦਧਨਪਫਬਭਮਯਰਲਵਸਹੜ੦੧੨੩੪੫੬੭੮੯ੲੳੴઅઆઇઈઉઊઋઌઍએઐઑઓઔકખગઘઙચછજઝઞટઠડઢણતથદધનપફબભમયરલળવશષસહઽૐૠૡ૦૧૨૩૪૫૬૭૮૯ૹଅଆଇଈଉଊଋଌଏଐଓଔକଖଗଘଙଚଛଜଝଞଟଠଡଢଣତଥଦଧନପଫବଭମଯରଲଳଵଶଷସହଽୟୠୡ୦୧୨୩୪୫୬୭୮୯ୱ୲୳୴୵୶୷ஃஅஆஇஈஉஊஎஏஐஒஓகஙசஜஞடணதநனபமயரறலளழவஶஷஸஹௐ௦௧௨௩௪௫௬௭௮௯௰௱௲అఆఇఈఉఊఋఌఎఏఐఒఓఔకఖగఘఙచఛజఝఞటఠడఢణతథదధనపఫబభమయరఱలళఴవశషసహఽౘౙౚౠౡ౦౧౨౩౪౫౬౭౮౯౸౹౺౻౼౽౾ಀಅಆಇಈಉಊಋಌಎಏಐಒಓಔಕಖಗಘಙಚಛಜಝಞಟಠಡಢಣತಥದಧನಪಫಬಭಮಯರಱಲಳವಶಷಸಹಽೞೠೡ೦೧೨೩೪೫೬೭೮೯ೱೲഅആഇഈഉഊഋഌഎഏഐഒഓഔകഖഗഘങചഛജഝഞടഠഡഢണതഥദധനഩപഫബഭമയരറലളഴവശഷസഹഺഽൎൔൕൖ൘൙൚൛൜൝൞ൟൠൡ൦൧൨൩൪൫൬൭൮൯൰൱൲൳൴൵൶൷൸ൺൻർൽൾൿඅආඇඈඉඊඋඌඍඎඏඐඑඒඓඔඕඖකඛගඝඞඟචඡජඣඤඥඦටඨඩඪණඬතථදධනඳපඵබභමඹයරලවශෂසහළෆ෦෧෨෩෪෫෬෭෮෯กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะาเแโใไๅ๐๑๒๓๔๕๖๗๘๙ກຂຄງຈຊຍດຕຖທນບປຜຝພຟມຢຣລວສຫອຮຯະາຽເແໂໃໄ໐໑໒໓໔໕໖໗໘໙ໞໟༀ༠༡༢༣༤༥༦༧༨༩༪༫༬༭༮༯༰༱༲༳ཀཁགངཅཆཇཉཊཋཌཎཏཐདནཔཕབམཙཚཛཝཞཟའཡརལཤཥསཧཨཪཫཬྈྉྊྋྌကခဂဃငစဆဇဈဉညဋဌဍဎဏတထဒဓနပဖဗဘမယရလဝသဟဠအဢဣဤဥဧဨဩဪဿ၀၁၂၃၄၅၆၇၈၉ၐၑၒၓၔၕ"],this.padChars.default=[..."01234567"],this.padCharAmount=8,this.hasSignedMode=!0,this.littleEndian=!1,this.utils.validateArgs(t,!0)}encode(t,...e){const r=this.utils.validateArgs(e);let n=this.utils.inputHandler.toBytes(t,r).at(0);const i=this.charsets[r.version],s=this.padChars[r.version];let o="",a=0,h=0;if(n.forEach((t=>{for(let e=this.converter.bsDec-1;e>=0;e--)a=(a<<1)+(t>>e&1),h++,h===this.converter.bsEnc&&(o+=i.at(a),a=0,h=0)})),0!==h){let t,e;for(h<=this.converter.bsEncPad?(t=this.converter.bsEncPad,e=!0):(t=this.converter.bsEnc,e=!1);h!==t;)if(a=1+(a<<1),h++,h>this.converter.bsEnc)throw new Error("Cannot process input. This is a bug!");o+=e?s.at(a):i.at(a)}return this.utils.wrapOutput(o,r.options.lineWrap)}decode(t,...e){const r=this.utils.validateArgs(e);t=this.utils.normalizeInput(t);const n=[...t],i=this.charsets[r.version],s=this.padChars[r.version],o=new Array;let a=0,h=0;if(n.forEach(((t,e)=>{let u,l=i.indexOf(t);if(l>-1)u=this.converter.bsEnc;else if(l=s.indexOf(t),l>-1){if(e+1!==n.length)throw new Error(`Secondary character found before end of input, index: ${e}`);u=this.converter.bsEncPad}else if(r.integrity)throw new CharsetError(t);for(let t=u-1;t>=0;t--)a=(a<<1)+(l>>t&1),h++,h===this.converter.bsDec&&(o.push(a),a=0,h=0)})),a!==(1<<h)-1)throw new TypeError("Padding mismatch");return this.utils.outputHandler.compile(Uint8Array.from(o),r.outputType)}}export{Base2048 as default};
