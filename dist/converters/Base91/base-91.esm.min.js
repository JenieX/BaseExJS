class t{static toBytes(t){return ArrayBuffer.isView(t)&&(t=t.buffer),[new Uint8Array(t),!1,"bytes"]}}class e{static get typeList(){return["buffer","bytes","uint8","view"]}static getType(t){if(!e.typeList.includes(t))throw new TypeError(`Unknown output type: '${t}'`);return t}static compile(t,i){let n;return n="buffer"===(i=e.getType(i))?t.buffer:"view"===i?new DataView(t.buffer):t,n}}class i{static makeDataView(t){const e=new ArrayBuffer(t);return new DataView(e)}static floatingPoints(t,e=!1){const i=this.makeDataView(8);return i.setFloat64(0,t,e),i}static numbers(t,e=!1){let i,n;if(Number.isInteger(t)){if(n="int",!Number.isSafeInteger(t)){let e,i,n;throw t<0?(e=Number.MIN_SAFE_INTEGER,i="smaller",n="MIN"):(e=Number.MAX_SAFE_INTEGER,i="bigger",n="MAX"),new RangeError(`The provided integer is ${i} than ${n}_SAFE_INTEGER: '${e}'\nData integrity is not guaranteed. Use a BigInt to avoid this issue.\n(If you see this error although a float was provided, the input has to many digits before the decimal point to store the decimal places in a float with 64 bits.)`)}t<0?t<-2147483648?(i=this.makeDataView(8),i.setBigInt64(0,BigInt(t),e)):t<-32768?(i=this.makeDataView(4),i.setInt32(0,t,e)):(i=this.makeDataView(2),i.setInt16(0,t,e)):t>0?t>4294967295?(i=this.makeDataView(8),i.setBigUint64(0,BigInt(t),e)):t>65535?(i=this.makeDataView(4),i.setUint32(0,t,e)):(i=this.makeDataView(2),i.setInt16(0,t,e)):i=new Uint16Array([0])}else n="float",i=this.floatingPoints(t,e);return[new Uint8Array(i.buffer),n]}static bigInts(t,e=!1){const i=new Array,n=e?"push":"unshift",r=18446744073709551616n;if(t<0)for(;t<-9223372036854775808n;)i[n](t%r),t>>=64n;else for(;t>=r;)i[n](t%r),t>>=64n;i[n](t);const s=8*i.length,o=this.makeDataView(s);return i.forEach(((t,i)=>{const n=8*i;o.setBigUint64(n,t,e)})),new Uint8Array(o.buffer)}static toBytes(t,e){let i,n=!1,r="bytes";if(t instanceof ArrayBuffer)i=new Uint8Array(t.slice());else if(ArrayBuffer.isView(t))i=new Uint8Array(t.buffer.slice());else if("string"==typeof t||t instanceof String)i=(new TextEncoder).encode(t);else if("number"==typeof t){if(isNaN(t))throw new TypeError("Cannot proceed. Input is NaN.");if(t==1/0)throw new TypeError("Cannot proceed. Input is Infinity.");if(e.signed&&t<0&&(n=!0,t=-t),e.numberMode){const n=this.floatingPoints(t,e.littleEndian);i=new Uint8Array(n.buffer),r="float"}else[i,r]=this.numbers(t,e.littleEndian)}else if("bigint"==typeof t)e.signed&&t<0&&(n=!0,t*=-1n),i=this.bigInts(t,e.littleEndian),r="int";else{if(!Array.isArray(t))throw new TypeError("The provided input type can not be processed.");{const n=new Array;for(const i of t)n.push(...this.toBytes(i,e)[0]);i=Uint8Array.from(n)}}return[i,n,r]}}const n=i,r=class{static get typeList(){return["bigint64","bigint_n","biguint64","buffer","bytes","float32","float64","float_n","int8","int16","int32","int_n","str","uint8","uint16","uint32","uint_n","view"]}static getType(t){if(!this.typeList.includes(t))throw new TypeError(`Unknown output type: '${t}'`);return t}static makeTypedArrayBuffer(t,e,i,n){const r=t.byteLength,s=(e-t.byteLength%e)%e,o=n&&r>1?255:0;let a=t;if(s){a=new Uint8Array(r+s),a.fill(o);const e=i?0:s;a.set(t,e)}return a.buffer}static makeTypedArray(t,e,i,n){let r;if("int16"===e||"uint16"===e){const s=this.makeTypedArrayBuffer(t,2,i,n);r="int16"===e?new Int16Array(s):new Uint16Array(s)}else if("int32"===e||"uint32"===e||"float32"===e){const s=this.makeTypedArrayBuffer(t,4,i,n);r="int32"===e?new Int32Array(s):"uint32"===e?new Uint32Array(s):new Float32Array(s)}else if("bigint64"===e||"biguint64"===e||"float64"===e){const s=this.makeTypedArrayBuffer(t,8,i,n);r="bigint64"===e?new BigInt64Array(s):"biguint64"===e?new BigUint64Array(s):new Float64Array(s)}return r}static compile(t,e,n=!1,r=!1){let s;if(e=this.getType(e),r){let r;if(r=e.match(/^float/)?-this.compile(t,"float_n",n):-this.compile(t,"uint_n",n),"float_n"===e)return r;t=i.toBytes(r,{littleEndian:n,numberMode:!1,signed:!1})[0]}if("buffer"===e)s=t.buffer;else if("bytes"===e||"uint8"===e)s=t;else if("int8"===e)s=new Int8Array(t.buffer);else if("view"===e)s=new DataView(t.buffer);else if("str"===e)s=(new TextDecoder).decode(t);else if("uint_n"===e||"int_n"===e||"bigint_n"===e){if(1===t.length){const e=this.makeTypedArrayBuffer(t,2,n,r);t=new Uint8Array(e)}n&&t.reverse();let i=0n;t.forEach((t=>i=(i<<8n)+BigInt(t))),"uint_n"!==e&&(i=BigInt.asIntN(8*t.length,i)),s="bigint_n"!==e&&i>=Number.MIN_SAFE_INTEGER&&i<=Number.MAX_SAFE_INTEGER?Number(i):i}else if("float_n"===e)if(t.length<=4){let e;e=4===t.length?t:this.makeTypedArray(t,"float32",!1,r);s=new DataView(e.buffer).getFloat32(0,n)}else{if(!(t.length<=8))throw new RangeError("The provided input is to complex to be converted into a floating point.");{let e;e=8===t.length?t:this.makeTypedArray(t,"float64",!1,r);s=new DataView(e.buffer).getFloat64(0,n)}}else if("number"===e){if(8!==t.length)throw new TypeError("Type mismatch. Cannot convert into number.");const e=new Float64Array(t.buffer);s=Number(e)}else s=this.makeTypedArray(t,e,n,r);return s}};class s extends TypeError{constructor(){super("The input is signed but the converter is not set to treat input as signed.\nYou can pass the string 'signed' to the decode function or when constructing the converter."),this.name="SignError"}}class o{constructor(t,e=!0){this.root=t,"charsets"in t&&e&&this.#t()}setIOHandlers(t=n,e=r){this.inputHandler=t,this.outputHandler=e}#t(){this.root.addCharset=(t,e)=>{if("string"!=typeof t)throw new TypeError("The charset name must be a string.");const i=this.root.converter.radix;let n=i;if("string"==typeof e||Array.isArray(e))n=e.length,e=new Set(e);else if(!(e instanceof Set))throw new TypeError("The charset must be one of the types:\n'str', 'set', 'array'.");if(e.size!==i)throw n===i?new Error("There were repetitive chars found in your charset. Make sure each char is unique."):new Error(`The length of the charset must be ${i}.`);e=[...e].join(""),this.root.charsets[t]=e,console.info(`New charset '${t}' was added and is ready to use`)},this.root.setDefaultCharset=t=>{({version:t}=this.validateArgs([t])),this.root.version=t}}makeArgList(t){return t.map((t=>`'${t}'`)).join(", ")}toSignedStr(t,e){return t=t.replace(/^0+(?!$)/,""),e&&(t="-".concat(t)),t}extractSign(t){let e=!1;return"-"===t[0]&&(e=!0,t=t.slice(1)),[t,e]}invalidArgument(t,e,i,n){const r=n?"\n * valid declarations for IO handlers are 'bytesOnly', 'bytesIn', 'bytesOut'":"",s=this.root.isMutable.signed?"\n * pass 'signed' to disable, 'unsigned' to enable the use of the twos's complement for negative integers":"",o=this.root.isMutable.littleEndian?"\n * 'be' for big , 'le' for little endian byte order for case conversion":"",a=this.root.isMutable.padding?"\n * pass 'pad' to fill up, 'nopad' to not fill up the output with the particular padding":"",l=this.root.isMutable.upper?"\n * valid args for changing the encoded output case are 'upper' and 'lower'":"",u=`\n * valid args for the output type are ${this.makeArgList(i)}`,h=e?`\n * the options for version (charset) are: ${this.makeArgList(e)}`:"";throw new TypeError(`'${t}'\n\nInput parameters:${r}${s}${o}${a}${l}${u}${h}\n * 'number' for number-mode (converts every number into a Float64Array to keep the natural js number type)\n\nTraceback:`)}validateArgs(i,s=!1){const o={littleEndian:this.root.littleEndian,numberMode:this.root.numberMode,outputType:this.root.outputType,padding:this.root.padding,signed:this.root.signed,upper:this.root.upper,version:this.root.version};if(!i.length)return s&&this.setIOHandlers(),o;const a=t=>!!i.includes(t)&&(i.splice(i.indexOf(t),1),!0),l=Object.prototype.hasOwnProperty.call(this.root,"charsets")?Object.keys(this.root.charsets):[],u={littleEndian:["be","le"],padding:["nopad","pad"],signed:["unsigned","signed"],upper:["lower","upper"]};if(s)if(a("bytes_only"))this.setIOHandlers(t,e);else{const i=a("bytes_in")?t:n,s=a("bytes_out")?e:r;this.setIOHandlers(i,s)}const h=this.outputHandler.typeList;if(a("number")&&(o.numberMode=!0,o.outputType="float_n"),i.forEach((t=>{if(t=String(t).toLowerCase(),l.includes(t))o.version=t;else if(h.includes(t))o.outputType=t;else{let e=!0;for(const i in u)if(u[i].includes(t)){if(e=!1,!this.root.isMutable[i])throw TypeError(`Argument '${t}' is not allowed for this type of converter.`);o[i]=Boolean(u[i].indexOf(t))}e&&this.invalidArgument(t,l,h,s)}})),o.padding&&o.signed&&(o.padding=!1,console.warn("Padding was set to false due to the signed conversion.")),s)for(const t in o)this.root[t]=o[t];return o}signError(){throw new s}}
/**
 * [BaseEx|Base91 Converter]{@link https://github.com/UmamiAppearance/BaseExJS/blob/main/src/converters/base-91.js}
 *
 * @version 0.5.0
 * @author UmamiAppearance [mail@umamiappearance.eu]
 * @license GPL-3.0 AND BSD-3-Clause (Base91, Copyright (c) 2000-2006 Joachim Henke)
 */
class a extends class{constructor(t=!0){this.charsets={},this.hasSignedMode=!1,this.littleEndian=!1,this.numberMode=!1,this.outputType="buffer",this.padding=!1,this.signed=!1,this.upper=null,t&&(this.utils=new o(this)),this.version="default",this.isMutable={littleEndian:!1,padding:!1,signed:!1,upper:!1}}encode(t,e,i,...n){const r=this.utils.validateArgs(n);let s,o,a;[s,o,a]=this.utils.inputHandler.toBytes(t,r);let l=null;e&&(l=e(r));let[u,h]=this.converter.encode(s,this.charsets[r.version],r.littleEndian,l);return r.signed&&(u=this.utils.toSignedStr(u,o)),r.upper&&(u=u.toUpperCase()),i&&(u=i({inputBytes:s,output:u,settings:r,zeroPadding:h,type:a})),u}decode(t,e,i,...n){const r=this.utils.validateArgs(n);t=String(t);let s=!1;this.hasSignedMode&&([t,s]=this.utils.extractSign(t),s&&!r.signed&&this.utils.signError()),this.isMutable.upper&&(t=t.toLowerCase()),e&&(t=e({input:t,settings:r}));let o=this.converter.decode(t,this.charsets[r.version],r.littleEndian);return i&&(o=i({input:t,output:o,settings:r})),this.utils.outputHandler.compile(o,r.outputType,r.littleEndian,s)}}{constructor(...t){super(),this.charsets.default=[...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,./:;<=>?@[]^_`{|}~"'],this.utils.validateArgs(t,!0)}encode(t,...e){const i=this.utils.validateArgs(e),n=this.utils.inputHandler.toBytes(t,i)[0];let r=0,s=0,o="";const a=this.charsets[i.version];if(n.forEach((t=>{if(s+=t<<r,r+=8,r>13){let t,e,i=13,n=s%8192;n<89&&(i=14,n=s%16384),s>>=i,r-=i,[t,e]=this.divmod(n,91),o=`${o}${a[e]}${a[t]}`}})),r){let t,e;[t,e]=this.divmod(s,91),o=o.concat(a[e]),(r>7||s>90)&&(o=o.concat(a[t]))}return o}decode(t,...e){const i=this.utils.validateArgs(e);let n=(t=String(t)).length,r=!1;n%2&&(r=!0,n--);let s=0,o=0;const a=this.charsets[i.version],l=new Array;for(let e=0;e<n;e+=2){const i=a.indexOf(t[e])+91*a.indexOf(t[e+1]);s=(i<<o)+s,o+=i%8192>88?13:14;do{l.push(s%256),s>>=8,o-=8}while(o>7)}if(r){const e=t.charAt(n),i=a.indexOf(e);l.push(((i<<o)+s)%256)}const u=Uint8Array.from(l);return this.utils.outputHandler.compile(u,i.outputType)}divmod(t,e){return[Math.floor(t/e),t%e]}}export{a as default};
