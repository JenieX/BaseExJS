class t{static toBytes(t){return ArrayBuffer.isView(t)&&(t=t.buffer),[new Uint8Array(t),!1,"bytes"]}}class e{static get typeList(){return["buffer","bytes","uint8","view"]}static getType(t){if(!e.typeList.includes(t))throw new TypeError(`Unknown output type: '${t}'`);return t}static compile(t,n){let r;return r="buffer"===(n=e.getType(n))?t.buffer:"view"===n?new DataView(t.buffer):t,r}}class n{static makeDataView(t){const e=new ArrayBuffer(t);return new DataView(e)}static floatingPoints(t,e=!1){const r=n.makeDataView(8);return r.setFloat64(0,t,e),r}static numbers(t,e=!1){let r,i;if(Number.isInteger(t)){if(i="int",!Number.isSafeInteger(t)){let e,n,r;throw t<0?(e=Number.MIN_SAFE_INTEGER,n="smaller",r="MIN"):(e=Number.MAX_SAFE_INTEGER,n="bigger",r="MAX"),new RangeError(`The provided integer is ${n} than ${r}_SAFE_INTEGER: '${e}'\nData integrity is not guaranteed. Use a BigInt to avoid this issue.\n(If you see this error although a float was provided, the input has to many digits before the decimal point to store the decimal places in a float with 64 bits.)`)}t<0?t<-2147483648?(r=n.makeDataView(8),r.setBigInt64(0,BigInt(t),e)):t<-32768?(r=n.makeDataView(4),r.setInt32(0,t,e)):(r=n.makeDataView(2),r.setInt16(0,t,e)):t>0?t>4294967295?(r=n.makeDataView(8),r.setBigUint64(0,BigInt(t),e)):t>65535?(r=n.makeDataView(4),r.setUint32(0,t,e)):(r=n.makeDataView(2),r.setInt16(0,t,e)):r=new Uint16Array([0])}else i="float",r=n.floatingPoints(t,e);return[new Uint8Array(r.buffer),i]}static bigInts(t,e=!1){const r=new Array,i=e?"push":"unshift",s=18446744073709551616n;if(t<0)for(;t<-9223372036854775808n;)r[i](t%s),t>>=64n;else for(;t>=s;)r[i](t%s),t>>=64n;r[i](t);const o=8*r.length,a=n.makeDataView(o);return r.forEach(((t,n)=>{const r=8*n;a.setBigUint64(r,t,e)})),new Uint8Array(a.buffer)}static toBytes(t,e){let r,i=!1,s="bytes";if(t instanceof ArrayBuffer)r=new Uint8Array(t);else if(ArrayBuffer.isView(t))r=new Uint8Array(t.buffer);else if("string"==typeof t||t instanceof String)r=(new TextEncoder).encode(t);else if("number"==typeof t){if(isNaN(t))throw new TypeError("Cannot proceed. Input is NaN.");if(t==1/0)throw new TypeError("Cannot proceed. Input is Infinity.");if(e.signed&&t<0&&(i=!0,t=-t),e.numberMode){const i=n.floatingPoints(t,e.littleEndian);r=new Uint8Array(i.buffer),s="float"}else[r,s]=n.numbers(t,e.littleEndian)}else if("bigint"==typeof t)e.signed&&t<0&&(i=!0,t*=-1n),r=n.bigInts(t,e.littleEndian),s="int";else{if(!Array.isArray(t))throw new TypeError("The provided input type can not be processed.");{const e=new Array;for(const r of t)e.push(...n.toBytes(r));r=Uint8Array.from(e)}}return[r,i,s]}}class r{static get typeList(){return["bigint64","bigint_n","biguint64","buffer","bytes","float32","float64","float_n","int8","int16","int32","int_n","str","uint8","uint16","uint32","uint_n","view"]}static getType(t){if(!r.typeList.includes(t))throw new TypeError(`Unknown output type: '${t}'`);return t}static makeTypedArrayBuffer(t,e,n){const r=t.byteLength,i=(e-t.byteLength%e)%e;let s=t;if(i){s=new Uint8Array(r+i);const e=n?i:0;s.set(t,e)}return s.buffer}static makeTypedArray(t,e,n){let i;if("int16"===e||"uint16"===e){const s=r.makeTypedArrayBuffer(t,2,n);i="int16"===e?new Int16Array(s):new Uint16Array(s)}else if("int32"===e||"uint32"===e||"float32"===e){const s=r.makeTypedArrayBuffer(t,4,n);i="int32"===e?new Int32Array(s):"uint32"===e?new Uint32Array(s):new Float32Array(s)}else if("bigint64"===e||"biguint64"===e||"float64"===e){const s=r.makeTypedArrayBuffer(t,8,n);i="bigint64"===e?new BigInt64Array(s):"biguint64"===e?new BigUint64Array(s):new Float64Array(s)}return i}static compile(t,e,n=!1,i=!1){let s;if("buffer"===(e=r.getType(e)))s=t.buffer;else if("bytes"===e||"uint8"===e)s=t;else if("int8"===e)s=new Int8Array(t.buffer);else if("view"===e)s=new DataView(t.buffer);else if("str"===e)s=(new TextDecoder).decode(t);else if("uint_n"===e||"int_n"===e||"bigint_n"===e){n&&t.reverse();let r=0n;t.forEach((t=>r=(r<<8n)+BigInt(t))),"int_n"===e&&(r=BigInt.asIntN(8*t.length,r)),s="bigint_n"!==e&&r>=Number.MIN_SAFE_INTEGER&&r<=Number.MAX_SAFE_INTEGER?Number(r):r,i&&(s=-s)}else if("float_n"===e)if(t.length<=4){let e;e=4===t.length?t:r.makeTypedArray(t,"float32",!1);s=new DataView(e.buffer).getFloat32(0,n)}else{if(!(t.length<=8))throw new RangeError("The provided input is to complex to be converted into a floating point.");{let e;e=8===t.length?t:r.makeTypedArray(t,"float64",!1);s=new DataView(e.buffer).getFloat64(0,n)}}else if("number"===e){if(8!==t.length)throw new TypeError("Type mismatch. Cannot convert into number.");const e=new Float64Array(t.buffer);s=Number(e)}else s=r.makeTypedArray(t,e,n);return s}}let i=n,s=r;class o{constructor(t){this.root=t,"charsets"in t&&this.charsetUserToolsConstructor()}setIOHandlers(t=i,e=s){this.inputHandler=t,this.outputHandler=e}charsetUserToolsConstructor(){this.root.addCharset=(t,e)=>{if("string"!=typeof t)throw new TypeError("The charset name must be a string.");const n=this.root.converter.radix;let r=n;if("string"==typeof e||Array.isArray(e))r=e.length,e=new Set(e);else if(!(e instanceof Set))throw new TypeError("The charset must be one of the types:\n'str', 'set', 'array'.");if(e.size!==n)throw r===n?new Error("There were repetitive chars found in your charset. Make sure each char is unique."):new Error(`The length of the charset must be ${n}.`);e=[...e].join(""),this.root.charsets[t]=e,console.log(`New charset added with the name '${t}' added and ready to use`)},this.root.setDefaultVersion=t=>[this.root.version]=this.validateArgs([t])}makeArgList(t){return t.map((t=>`'${t}'`)).join(", ")}toSignedStr(t,e){return t=t.replace(/^0+(?!$)/,""),e&&(t="-".concat(t)),t}extractSign(t){let e=!1;return"-"===t[0]&&(e=!0,t=t.slice(1)),[t,e]}invalidArgument(t,e,n,r){const i=r?"\n * valid declarations for IO handlers are 'bytesOnly', 'bytesIn', 'bytesOut'":"",s=this.root.isMutable.signed?"\n * pass 'signed' to disable, 'unsigned', to enable the use of the twos's complement for negative integers":"",o=this.root.isMutable.littleEndian?"\n * 'be' for big , 'le' for little endian byte order for case conversion":"",a=this.root.isMutable.padding?"\n * pass 'pad' to fill up, 'nopad' to not fill up the output with the particular padding":"",u=this.root.isMutable.upper?"\n * valid args for changing the encoded output case are 'upper' and 'lower'":"",l=`\n * valid args for the output type are ${this.makeArgList(n)}`,d=e?`\n * the options for version (charset) are: ${this.makeArgList(e)}`:"";throw new TypeError(`'${t}'\n\nInput parameters:${i}${s}${o}${a}${u}${l}${d}\n * 'number' for number-mode (converts every number into a Float64Array to keep the natural js number type)\n\nTraceback:`)}validateArgs(n,r=!1){const o={littleEndian:this.root.littleEndian,numberMode:this.root.numberMode,outputType:this.root.outputType,padding:this.root.padding,signed:this.root.signed,upper:this.root.upper,version:this.root.version};if(!n.length)return r&&this.setIOHandlers(),o;const a=t=>!!n.includes(t)&&(n.splice(n.indexOf(t),1),!0),u=Object.keys(this.root.charsets),l={littleEndian:["be","le"],padding:["nopad","pad"],signed:["unsigned","signed"],upper:["lower","upper"]};if(r)if(a("bytes_only"))this.setIOHandlers(t,e);else{const n=a("bytes_in")?t:i,r=a("bytes_out")?e:s;this.setIOHandlers(n,r)}const d=this.outputHandler.typeList;if(a("number")&&(o.numberMode=!0,o.outputType="float_n"),n.forEach((t=>{if(t=String(t).toLowerCase(),u.includes(t))o.version=t;else if(d.includes(t))o.outputType=t;else{let e=!0;for(const n in l)if(l[n].includes(t)){if(e=!1,!this.root.isMutable[n])throw TypeError(`Argument '${t}' is not allowed for this type of converter.`);o[n]=Boolean(l[n].indexOf(t))}e&&this.invalidArgument(t,u,d,r)}})),o.padding&&o.signed&&(o.padding=!1,this.constructor.warning("Padding was set to false due to the signed conversion.")),r)for(const t in o)this.root[t]=o[t];return o}signError(){throw new TypeError("The input is signed but the converter is not set to treat input as signed.\nYou can pass the string 'signed' to the decode function or when constructing the converter.")}static warning(t){Object.prototype.hasOwnProperty.call(console,"warn")?console.warn(t):console.log(`___\n${t}\n`)}}class a extends class{constructor(){this.charsets={},this.hasSignedMode=!1,this.littleEndian=!1,this.numberMode=!1,this.outputType="buffer",this.padding=!1,this.signed=!1,this.upper=null,this.utils=new o(this),this.version="default",this.isMutable={littleEndian:!1,padding:!1,signed:!1,upper:!1}}encode(t,e,n,...r){const i=this.utils.validateArgs(r);let s,o,a;[s,o,a]=this.utils.inputHandler.toBytes(t,i);let u,l,d=null;return e&&(d=e(i)),[u,l]=this.converter.encode(s,this.charsets[i.version],i.littleEndian,d),i.signed&&(u=this.utils.toSignedStr(u,o)),i.upper&&(u=u.toUpperCase()),n&&(u=n({inputBytes:s,output:u,settings:i,zeroPadding:l,type:a})),u}decode(t,e,n,...r){const i=this.utils.validateArgs(r);let s=String(t),o=!1;this.hasSignedMode&&([s,o]=this.utils.extractSign(s),o&&!i.signed&&this.utils.signError()),this.isMutable.upper&&(s=s.toLowerCase()),e&&(s=e({input:s,settings:i}));let a=this.converter.decode(s,this.charsets[i.version],i.littleEndian);return n&&(a=n({input:s,output:a,settings:i})),this.utils.outputHandler.compile(a,i.outputType,i.littleEndian,o)}}{constructor(...t){super(),this.charsets.default='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,./:;<=>?@[]^_`{|}~"',this.version="default",this.utils.validateArgs(t,!0)}encode(t,...e){const n=this.utils.validateArgs(e),r=this.utils.inputHandler.toBytes(t,n)[0];let i=0,s=0,o="";const a=this.charsets[n.version];if(r.forEach((t=>{if(s+=t<<i,i+=8,i>13){let t,e,n=13,r=s%8192;r<89&&(n=14,r=s%16384),s>>=n,i-=n,[t,e]=this.divmod(r,91),o=`${o}${a[e]}${a[t]}`}})),i){let t,e;[t,e]=this.divmod(s,91),o=o.concat(a[e]),(i>7||s>90)&&(o=o.concat(a[t]))}return o}decode(t,...e){const n=this.utils.validateArgs(e);let r=(t=String(t)).length,i=!1;r%2&&(i=!0,r--);let s=0,o=0;const a=this.charsets[n.version],u=new Array;for(let e=0;e<r;e+=2){const n=a.indexOf(t[e])+91*a.indexOf(t[e+1]);s=(n<<o)+s,o+=n%8192>88?13:14;do{u.push(s%256),s>>=8,o-=8}while(o>7)}if(i){const e=t.charAt(r),n=a.indexOf(e);u.push(((n<<o)+s)%256)}const l=Uint8Array.from(u);return this.utils.outputHandler.compile(l,n.outputType)}divmod(t,e){return[Math.floor(t/e),t%e]}}export{a as Base91};
