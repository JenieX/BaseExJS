class BytesInput{static toBytes(t){return ArrayBuffer.isView(t)&&(t=t.buffer),[new Uint8Array(t),!1,"bytes"]}}class BytesOutput{static get typeList(){return["buffer","bytes","uint8","view"]}static getType(t){if(!BytesOutput.typeList.includes(t))throw new TypeError(`Unknown output type: '${t}'`);return t}static compile(t,e){let r;return r="buffer"===(e=BytesOutput.getType(e))?t.buffer:"view"===e?new DataView(t.buffer):t,r}}class SmartInput{static makeDataView(t){const e=new ArrayBuffer(t);return new DataView(e)}static floatingPoints(t,e=!1){const r=this.makeDataView(8);return r.setFloat64(0,t,e),r}static numbers(t,e=!1){let r,n;if(Number.isInteger(t)){if(n="int",!Number.isSafeInteger(t)){let e,r,n;throw t<0?(e=Number.MIN_SAFE_INTEGER,r="smaller",n="MIN"):(e=Number.MAX_SAFE_INTEGER,r="bigger",n="MAX"),new RangeError(`The provided integer is ${r} than ${n}_SAFE_INTEGER: '${e}'\nData integrity is not guaranteed. Use a BigInt to avoid this issue.\n(If you see this error although a float was provided, the input has to many digits before the decimal point to store the decimal places in a float with 64 bits.)`)}t<0?t<-2147483648?(r=this.makeDataView(8),r.setBigInt64(0,BigInt(t),e)):t<-32768?(r=this.makeDataView(4),r.setInt32(0,t,e)):(r=this.makeDataView(2),r.setInt16(0,t,e)):t>0?t>4294967295?(r=this.makeDataView(8),r.setBigUint64(0,BigInt(t),e)):t>65535?(r=this.makeDataView(4),r.setUint32(0,t,e)):(r=this.makeDataView(2),r.setInt16(0,t,e)):r=new Uint16Array([0])}else n="float",r=this.floatingPoints(t,e);return[new Uint8Array(r.buffer),n]}static bigInts(t,e=!1){const r=new Array,n=e?"push":"unshift",i=18446744073709551616n;if(t<0)for(;t<-9223372036854775808n;)r[n](t%i),t>>=64n;else for(;t>=i;)r[n](t%i),t>>=64n;r[n](t);const s=8*r.length,o=this.makeDataView(s);return r.forEach(((t,r)=>{const n=8*r;o.setBigUint64(n,t,e)})),new Uint8Array(o.buffer)}static toBytes(t,e){let r,n=!1,i="bytes";if(t instanceof ArrayBuffer)r=new Uint8Array(t.slice());else if(ArrayBuffer.isView(t))r=new Uint8Array(t.buffer.slice());else if("string"==typeof t||t instanceof String)r=(new TextEncoder).encode(t);else if("number"==typeof t){if(isNaN(t))throw new TypeError("Cannot proceed. Input is NaN.");if(t==1/0)throw new TypeError("Cannot proceed. Input is Infinity.");if(e.signed&&t<0&&(n=!0,t=-t),e.numberMode){const n=this.floatingPoints(t,e.littleEndian);r=new Uint8Array(n.buffer),i="float"}else[r,i]=this.numbers(t,e.littleEndian)}else if("bigint"==typeof t)e.signed&&t<0&&(n=!0,t*=-1n),r=this.bigInts(t,e.littleEndian),i="int";else{if(!Array.isArray(t))throw new TypeError("The provided input type can not be processed.");{const n=new Array;for(const r of t)n.push(...this.toBytes(r,e)[0]);r=Uint8Array.from(n)}}return[r,n,i]}}class SmartOutput{static get typeList(){return["bigint64","bigint_n","biguint64","buffer","bytes","float32","float64","float_n","int8","int16","int32","int_n","str","uint8","uint16","uint32","uint_n","view"]}static getType(t){if(!this.typeList.includes(t))throw new TypeError(`Unknown output type: '${t}'`);return t}static makeTypedArrayBuffer(t,e,r,n){const i=t.byteLength,s=(e-t.byteLength%e)%e,o=n&&i>1?255:0;let a=t;if(s){a=new Uint8Array(i+s),a.fill(o);const e=r?0:s;a.set(t,e)}return a.buffer}static makeTypedArray(t,e,r,n){let i;if("int16"===e||"uint16"===e){const s=this.makeTypedArrayBuffer(t,2,r,n);i="int16"===e?new Int16Array(s):new Uint16Array(s)}else if("int32"===e||"uint32"===e||"float32"===e){const s=this.makeTypedArrayBuffer(t,4,r,n);i="int32"===e?new Int32Array(s):"uint32"===e?new Uint32Array(s):new Float32Array(s)}else if("bigint64"===e||"biguint64"===e||"float64"===e){const s=this.makeTypedArrayBuffer(t,8,r,n);i="bigint64"===e?new BigInt64Array(s):"biguint64"===e?new BigUint64Array(s):new Float64Array(s)}return i}static compile(t,e,r=!1,n=!1){let i;if(e=this.getType(e),n){let n;if(n=e.match(/^float/)?-this.compile(t,"float_n",r):-this.compile(t,"uint_n",r),"float_n"===e)return n;t=SmartInput.toBytes(n,{littleEndian:r,numberMode:!1,signed:!1})[0]}if("buffer"===e)i=t.buffer;else if("bytes"===e||"uint8"===e)i=t;else if("int8"===e)i=new Int8Array(t.buffer);else if("view"===e)i=new DataView(t.buffer);else if("str"===e)i=(new TextDecoder).decode(t);else if("uint_n"===e||"int_n"===e||"bigint_n"===e){if(1===t.length){const e=this.makeTypedArrayBuffer(t,2,r,n);t=new Uint8Array(e)}r&&t.reverse();let s=0n;t.forEach((t=>s=(s<<8n)+BigInt(t))),"uint_n"!==e&&(s=BigInt.asIntN(8*t.length,s)),i="bigint_n"!==e&&s>=Number.MIN_SAFE_INTEGER&&s<=Number.MAX_SAFE_INTEGER?Number(s):s}else if("float_n"===e)if(t.length<=4){let e;e=4===t.length?t:this.makeTypedArray(t,"float32",!1,n);i=new DataView(e.buffer).getFloat32(0,r)}else{if(!(t.length<=8))throw new RangeError("The provided input is to complex to be converted into a floating point.");{let e;e=8===t.length?t:this.makeTypedArray(t,"float64",!1,n);i=new DataView(e.buffer).getFloat64(0,r)}}else if("number"===e){if(8!==t.length)throw new TypeError("Type mismatch. Cannot convert into number.");const e=new Float64Array(t.buffer);i=Number(e)}else i=this.makeTypedArray(t,e,r,n);return i}}const DEFAULT_INPUT_HANDLER=SmartInput,DEFAULT_OUTPUT_HANDLER=SmartOutput;class SignError extends TypeError{constructor(){super("The input is signed but the converter is not set to treat input as signed.\nYou can pass the string 'signed' to the decode function or when constructing the converter."),this.name="SignError"}}class CharsetError extends TypeError{constructor(t){super(`Invalid input. Character: '${t}' is not part of the charset.`),this.name="CharsetError"}}class Utils{constructor(t){this.root=t,this.converterArgs={},this.#t()}setIOHandlers(t=DEFAULT_INPUT_HANDLER,e=DEFAULT_OUTPUT_HANDLER){this.inputHandler=t,this.outputHandler=e}#t(){this.root.addCharset=(t,e,r=[],n=!0)=>{const i=(t,r,n)=>{if(0===n&&r.length)return console.warn(`This converter has no ${t}. The following argument was ignored:\n'${r}'`),[];let i=n;if("string"==typeof r&&(r=[...r]),Array.isArray(r))i=r.length,r=new Set(r);else if(!(r instanceof Set))throw new TypeError(`The ${t} must be one of the types:\n'str', 'set', 'array'."`);if(r.size===n)return[...r];if(i!==n)throw new Error(`Your ${t} has a length of ${i}. The converter requires a length of ${n}.`);{const r={};(e=[...e]).forEach((t=>{t in r?r[t]++:r[t]=1}));let i="";n<100&&(i=`${e.join("")}\n`,e.forEach((t=>{r[t]>1?i+="^":i+=" "})));const s=Object.keys(r).filter((t=>r[t]>1));throw new Error(`You have repetitive char(s) [ ${s.join(" | ")} ] in your ${t}. Make sure each character is unique.\n${i}`)}};if(this.root.frozenCharsets)throw new Error("The charsets of this converter cannot be changed.");if("string"!=typeof t)throw new TypeError("The charset name must be a string.");n&&t in this.root.charsets&&console.warn(`An existing charset with name ${t} will get replaced.`);const s=i("charset",e,this.root.converter.radix),o=i("padding set",r,this.root.padCharAmount);this.root.charsets[t]=s,o.length&&(this.root.padChars[t]=o),n&&console.info(`New charset '${t}' was added and is ready to use`)},this.root.setDefaultCharset=t=>{if(!(t in this.root.charsets)){const e=Object.keys(this.root.charsets).join("\n   * ");throw new TypeError(`Charset ${t} was not found. Available charsets are:\n   * ${e}`)}this.root.version=t}}#e(t){return t.map((t=>`'${t}'`)).join(", ")}toSignedStr(t,e){return t=t.replace(/^0+(?!$)/,""),e&&(t="-".concat(t)),t}extractSign(t){let e=!1;return"-"===t[0]&&(e=!0,t=t.slice(1)),[t,e]}#r(t,e,r,n){const i=n?"\n * valid declarations for IO handlers are 'bytesOnly', 'bytesIn', 'bytesOut'":"",s=this.root.isMutable.signed?"\n * pass 'signed' to disable, 'unsigned' to enable the use of the twos's complement for negative integers":"",o=this.root.isMutable.littleEndian?"\n * 'be' for big , 'le' for little endian byte order for case conversion":"",a=this.root.isMutable.padding?"\n * pass 'pad' to fill up, 'nopad' to not fill up the output with the particular padding":"",u=this.root.isMutable.upper?"\n * valid args for changing the encoded output case are 'upper' and 'lower'":"",h=`\n * valid args for the output type are ${this.#e(r)}`,l=e?`\n * the option(s) for version/charset are: ${this.#e(e)}`:"",c=Object.keys(this.converterArgs).length?`\n * converter specific args:\n   - ${(()=>Object.keys(this.converterArgs).map((t=>this.converterArgs[t].map((t=>`'${t}'`)).join(" and "))).join("\n   - "))()}`:"";throw new TypeError(`'${t}'\n\nParameters:${i}${s}${o}${a}${u}${h}${l}\n * valid args for integrity check are: 'integrity' and 'nointegrity'\n * 'number' for number-mode (converts every number into a Float64Array to keep the natural js number type)${c}\n\nTraceback:`)}validateArgs(t,e=!1){const r={decimalMode:this.root.decimalMode,integrity:this.root.integrity,littleEndian:this.root.littleEndian,numberMode:this.root.numberMode,options:this.root.options,outputType:this.root.outputType,padding:this.root.padding,signed:this.root.signed,upper:this.root.upper,version:this.root.version};for(const t in this.converterArgs)r[t]=this.root[t];if(!t.length)return e&&this.setIOHandlers(),r;const n=e=>!!t.includes(e)&&(t.splice(t.indexOf(e),1),!0),i=Object.keys(this.root.charsets),s={integrity:["nointegrity","integrity"],littleEndian:["be","le"],padding:["nopad","pad"],signed:["unsigned","signed"],upper:["lower","upper"],...this.converterArgs};if(e)if(n("bytes_only"))this.setIOHandlers(BytesInput,BytesOutput);else{const t=n("bytes_in")?BytesInput:DEFAULT_INPUT_HANDLER,e=n("bytes_out")?BytesOutput:DEFAULT_OUTPUT_HANDLER;this.setIOHandlers(t,e)}const o=this.outputHandler.typeList;if(n("number")?(r.numberMode=!0,r.outputType="float_n"):n("decimal")&&(r.decimalMode=!0,r.outputType="decimal"),t.forEach((t=>{if("object"!=typeof t)if(t=String(t).toLowerCase(),i.includes(t))r.version=t;else if(o.includes(t))r.outputType=t;else{let n=!0;for(const e in s)if(s[e].includes(t)){if(n=!1,!this.root.isMutable[e])throw TypeError(`Argument '${t}' is not allowed for this type of converter.`);r[e]=Boolean(s[e].indexOf(t))}n&&this.#r(t,i,o,e)}else r.options={...r.options,...t}})),r.padding&&r.signed&&(r.padding=!1,console.warn("Padding was set to false due to the signed conversion.")),e)for(const t in r)this.root[t]=r[t];return r}signError(){throw new SignError}wrapOutput(t,e=0){if(!e)return t;const r=new RegExp(`.{1,${e}}`,"gu");return t.match(r).join("\n")}normalizeInput(t,e=!1){return e?String(t):String(t).replace(/\n/g,"")}}class BaseConverter{constructor(t,e=null,r=null,n=0){this.radix=t,null!==e&&null!==r?(this.bsEnc=e,this.bsDec=r):[this.bsEnc,this.bsDec]=this.constructor.guessBS(t),this.decPadVal=n}static guessBS(t){let e=t<8?t:Math.ceil(256/t);for(;e>8&&!(e%8);)e/=8;let r=0;for(;8*r*Math.log(2)/Math.log(t)<e;)r++;return[r,Math.ceil(8*r*Math.log(2)/Math.log(t))]}encode(t,e,r=!1,n=null){let i=this.bsEnc;0===i&&(i=t.byteLength);let s="";const o=i?(i-t.length%i)%i:0,a=new Array(o).fill(0);let u;if(r?(t.reverse(),u=[...a,...t]):u=[...t,...a],10===this.radix){let t=0n;for(let e=0;e<i;e++)t=(t<<8n)+BigInt(u[e]);return[t.toString(),0]}for(let t=0,r=u.length;t<r;t+=i){let r=0n;for(let e=t;e<t+i;e++)r=(r<<8n)+BigInt(u[e]);const a=new Array;let h,l=r;for(;l>=this.radix;)[l,h]=this.divmod(l,this.radix),a.unshift(parseInt(h,10));for(a.unshift(parseInt(l,10));a.length<this.bsDec;)a.unshift(0);let c="";a.forEach((t=>c=c.concat(e[t]))),n&&(c=n(c,o)),s=s.concat(c)}return[s,o]}decode(t,e,r=[],n=!0,i=!1){if(!t)return new Uint8Array(0);let s=this.bsDec;const o=new Array;let a;if([...t].forEach((t=>{const i=e.indexOf(t);if(i>-1)o.push(i);else if(n&&-1===r.indexOf(t))throw new CharsetError(t)})),0===s)s=o.length;else{a=(s-o.length%s)%s;const t=new Array(a).fill(this.decPadVal);i?o.unshift(...t):o.push(...t)}let u=new Array;for(let t=0,e=o.length;t<e;t+=s){let e=0n;for(let r=0;r<s;r++)e+=BigInt(o[t+r])*this.pow(s-1-r);const r=new Array;let n,i=e;for(;i>=256;)[i,n]=this.divmod(i,256),r.unshift(parseInt(n,10));for(r.unshift(parseInt(i,10));r.length<this.bsEnc;)r.unshift(0);u=u.concat(r)}if(i){if(u.length>1){for(;!u[0];)u.shift();u.length||u.push(0),u.reverse()}}else if(this.bsDec){const t=this.padChars(a);u.splice(u.length-t)}return Uint8Array.from(u)}padBytes(t){return Math.floor(t*this.bsDec/this.bsEnc)}padChars(t){return Math.ceil(t*this.bsEnc/this.bsDec)}pow(t){return BigInt(this.radix)**BigInt(t)}divmod(t,e){return[t,e]=[BigInt(t),BigInt(e)],[t/e,t%e]}}class BaseTemplate{constructor(t=!0){this.charsets={},this.decimalMode=!1,this.frozenCharsets=!1,this.hasSignedMode=!1,this.integrity=!0,this.littleEndian=!1,this.numberMode=!1,this.outputType="buffer",this.padding=!1,this.padCharAmount=0,this.padChars={},this.signed=!1,this.upper=null,t&&(this.utils=new Utils(this)),this.version="default",this.options={lineWrap:0},this.isMutable={integrity:!0,littleEndian:!1,padding:!1,signed:!1,upper:!1}}encode(t,e,r,...n){const i=this.utils.validateArgs(n);let[s,o,a]=this.utils.inputHandler.toBytes(t,i),u=null;e&&(u=e(i));let[h,l]=this.converter.encode(s,this.charsets[i.version],i.littleEndian,u);return i.signed&&(h=this.utils.toSignedStr(h,o)),i.upper&&(h=h.toUpperCase()),r&&(h=r({inputBytes:s,output:h,settings:i,zeroPadding:l,type:a})),this.utils.wrapOutput(h,i.options.lineWrap)}decode(t,e,r,n,...i){const s=this.utils.validateArgs(i);t=this.utils.normalizeInput(t,n);let o=!1;this.hasSignedMode&&([t,o]=this.utils.extractSign(t),o&&!s.signed&&this.utils.signError()),this.isMutable.upper&&(t=t.toLowerCase()),e&&(t=e({input:t,settings:s}));let a=this.converter.decode(t,this.charsets[s.version],this.padChars[s.version],s.integrity,s.littleEndian);return r&&(a=r({input:t,output:a,settings:s})),this.utils.outputHandler.compile(a,s.outputType,s.littleEndian,o)}}var DP=20,RM=1,MAX_DP=1e6,MAX_POWER=1e6,NE=-7,PE=21,STRICT=!1,NAME="[big.js] ",INVALID=NAME+"Invalid ",INVALID_DP=INVALID+"decimal places",INVALID_RM=INVALID+"rounding mode",DIV_BY_ZERO=NAME+"Division by zero",P={},UNDEFINED=void 0,NUMERIC=/^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;function _Big_(){function t(e){var r=this;if(!(r instanceof t))return e===UNDEFINED?_Big_():new t(e);if(e instanceof t)r.s=e.s,r.e=e.e,r.c=e.c.slice();else{if("string"!=typeof e){if(!0===t.strict&&"bigint"!=typeof e)throw TypeError(INVALID+"value");e=0===e&&1/e<0?"-0":String(e)}parse(r,e)}r.constructor=t}return t.prototype=P,t.DP=DP,t.RM=RM,t.NE=NE,t.PE=PE,t.strict=STRICT,t.roundDown=0,t.roundHalfUp=1,t.roundHalfEven=2,t.roundUp=3,t}function parse(t,e){var r,n,i;if(!NUMERIC.test(e))throw Error(INVALID+"number");for(t.s="-"==e.charAt(0)?(e=e.slice(1),-1):1,(r=e.indexOf("."))>-1&&(e=e.replace(".","")),(n=e.search(/e/i))>0?(r<0&&(r=n),r+=+e.slice(n+1),e=e.substring(0,n)):r<0&&(r=e.length),i=e.length,n=0;n<i&&"0"==e.charAt(n);)++n;if(n==i)t.c=[t.e=0];else{for(;i>0&&"0"==e.charAt(--i););for(t.e=r-n-1,t.c=[],r=0;n<=i;)t.c[r++]=+e.charAt(n++)}return t}function round(t,e,r,n){var i=t.c;if(r===UNDEFINED&&(r=t.constructor.RM),0!==r&&1!==r&&2!==r&&3!==r)throw Error(INVALID_RM);if(e<1)n=3===r&&(n||!!i[0])||0===e&&(1===r&&i[0]>=5||2===r&&(i[0]>5||5===i[0]&&(n||i[1]!==UNDEFINED))),i.length=1,n?(t.e=t.e-e+1,i[0]=1):i[0]=t.e=0;else if(e<i.length){if(n=1===r&&i[e]>=5||2===r&&(i[e]>5||5===i[e]&&(n||i[e+1]!==UNDEFINED||1&i[e-1]))||3===r&&(n||!!i[0]),i.length=e,n)for(;++i[--e]>9;)if(i[e]=0,0===e){++t.e,i.unshift(1);break}for(e=i.length;!i[--e];)i.pop()}return t}function stringify(t,e,r){var n=t.e,i=t.c.join(""),s=i.length;if(e)i=i.charAt(0)+(s>1?"."+i.slice(1):"")+(n<0?"e":"e+")+n;else if(n<0){for(;++n;)i="0"+i;i="0."+i}else if(n>0)if(++n>s)for(n-=s;n--;)i+="0";else n<s&&(i=i.slice(0,n)+"."+i.slice(n));else s>1&&(i=i.charAt(0)+"."+i.slice(1));return t.s<0&&r?"-"+i:i}P.abs=function(){var t=new this.constructor(this);return t.s=1,t},P.cmp=function(t){var e,r=this,n=r.c,i=(t=new r.constructor(t)).c,s=r.s,o=t.s,a=r.e,u=t.e;if(!n[0]||!i[0])return n[0]?s:i[0]?-o:0;if(s!=o)return s;if(e=s<0,a!=u)return a>u^e?1:-1;for(o=(a=n.length)<(u=i.length)?a:u,s=-1;++s<o;)if(n[s]!=i[s])return n[s]>i[s]^e?1:-1;return a==u?0:a>u^e?1:-1},P.div=function(t){var e=this,r=e.constructor,n=e.c,i=(t=new r(t)).c,s=e.s==t.s?1:-1,o=r.DP;if(o!==~~o||o<0||o>MAX_DP)throw Error(INVALID_DP);if(!i[0])throw Error(DIV_BY_ZERO);if(!n[0])return t.s=s,t.c=[t.e=0],t;var a,u,h,l,c,f=i.slice(),p=a=i.length,d=n.length,g=n.slice(0,a),y=g.length,w=t,E=w.c=[],b=0,m=o+(w.e=e.e-t.e)+1;for(w.s=s,s=m<0?0:m,f.unshift(0);y++<a;)g.push(0);do{for(h=0;h<10;h++){if(a!=(y=g.length))l=a>y?1:-1;else for(c=-1,l=0;++c<a;)if(i[c]!=g[c]){l=i[c]>g[c]?1:-1;break}if(!(l<0))break;for(u=y==a?i:f;y;){if(g[--y]<u[y]){for(c=y;c&&!g[--c];)g[c]=9;--g[c],g[y]+=10}g[y]-=u[y]}for(;!g[0];)g.shift()}E[b++]=l?h:++h,g[0]&&l?g[y]=n[p]||0:g=[n[p]]}while((p++<d||g[0]!==UNDEFINED)&&s--);return E[0]||1==b||(E.shift(),w.e--,m--),b>m&&round(w,m,r.RM,g[0]!==UNDEFINED),w},P.eq=function(t){return 0===this.cmp(t)},P.gt=function(t){return this.cmp(t)>0},P.gte=function(t){return this.cmp(t)>-1},P.lt=function(t){return this.cmp(t)<0},P.lte=function(t){return this.cmp(t)<1},P.minus=P.sub=function(t){var e,r,n,i,s=this,o=s.constructor,a=s.s,u=(t=new o(t)).s;if(a!=u)return t.s=-u,s.plus(t);var h=s.c.slice(),l=s.e,c=t.c,f=t.e;if(!h[0]||!c[0])return c[0]?t.s=-u:h[0]?t=new o(s):t.s=1,t;if(a=l-f){for((i=a<0)?(a=-a,n=h):(f=l,n=c),n.reverse(),u=a;u--;)n.push(0);n.reverse()}else for(r=((i=h.length<c.length)?h:c).length,a=u=0;u<r;u++)if(h[u]!=c[u]){i=h[u]<c[u];break}if(i&&(n=h,h=c,c=n,t.s=-t.s),(u=(r=c.length)-(e=h.length))>0)for(;u--;)h[e++]=0;for(u=e;r>a;){if(h[--r]<c[r]){for(e=r;e&&!h[--e];)h[e]=9;--h[e],h[r]+=10}h[r]-=c[r]}for(;0===h[--u];)h.pop();for(;0===h[0];)h.shift(),--f;return h[0]||(t.s=1,h=[f=0]),t.c=h,t.e=f,t},P.mod=function(t){var e,r=this,n=r.constructor,i=r.s,s=(t=new n(t)).s;if(!t.c[0])throw Error(DIV_BY_ZERO);return r.s=t.s=1,e=1==t.cmp(r),r.s=i,t.s=s,e?new n(r):(i=n.DP,s=n.RM,n.DP=n.RM=0,r=r.div(t),n.DP=i,n.RM=s,this.minus(r.times(t)))},P.neg=function(){var t=new this.constructor(this);return t.s=-t.s,t},P.plus=P.add=function(t){var e,r,n,i=this,s=i.constructor;if(t=new s(t),i.s!=t.s)return t.s=-t.s,i.minus(t);var o=i.e,a=i.c,u=t.e,h=t.c;if(!a[0]||!h[0])return h[0]||(a[0]?t=new s(i):t.s=i.s),t;if(a=a.slice(),e=o-u){for(e>0?(u=o,n=h):(e=-e,n=a),n.reverse();e--;)n.push(0);n.reverse()}for(a.length-h.length<0&&(n=h,h=a,a=n),e=h.length,r=0;e;a[e]%=10)r=(a[--e]=a[e]+h[e]+r)/10|0;for(r&&(a.unshift(r),++u),e=a.length;0===a[--e];)a.pop();return t.c=a,t.e=u,t},P.pow=function(t){var e=this,r=new e.constructor("1"),n=r,i=t<0;if(t!==~~t||t<-MAX_POWER||t>MAX_POWER)throw Error(INVALID+"exponent");for(i&&(t=-t);1&t&&(n=n.times(e)),t>>=1;)e=e.times(e);return i?r.div(n):n},P.prec=function(t,e){if(t!==~~t||t<1||t>MAX_DP)throw Error(INVALID+"precision");return round(new this.constructor(this),t,e)},P.round=function(t,e){if(t===UNDEFINED)t=0;else if(t!==~~t||t<-MAX_DP||t>MAX_DP)throw Error(INVALID_DP);return round(new this.constructor(this),t+this.e+1,e)},P.sqrt=function(){var t,e,r,n=this,i=n.constructor,s=n.s,o=n.e,a=new i("0.5");if(!n.c[0])return new i(n);if(s<0)throw Error(NAME+"No square root");0===(s=Math.sqrt(n+""))||s===1/0?((e=n.c.join("")).length+o&1||(e+="0"),o=((o+1)/2|0)-(o<0||1&o),t=new i(((s=Math.sqrt(e))==1/0?"5e":(s=s.toExponential()).slice(0,s.indexOf("e")+1))+o)):t=new i(s+""),o=t.e+(i.DP+=4);do{r=t,t=a.times(r.plus(n.div(r)))}while(r.c.slice(0,o).join("")!==t.c.slice(0,o).join(""));return round(t,(i.DP-=4)+t.e+1,i.RM)},P.times=P.mul=function(t){var e,r=this,n=r.constructor,i=r.c,s=(t=new n(t)).c,o=i.length,a=s.length,u=r.e,h=t.e;if(t.s=r.s==t.s?1:-1,!i[0]||!s[0])return t.c=[t.e=0],t;for(t.e=u+h,o<a&&(e=i,i=s,s=e,h=o,o=a,a=h),e=new Array(h=o+a);h--;)e[h]=0;for(u=a;u--;){for(a=0,h=o+u;h>u;)a=e[h]+s[u]*i[h-u-1]+a,e[h--]=a%10,a=a/10|0;e[h]=a}for(a?++t.e:e.shift(),u=e.length;!e[--u];)e.pop();return t.c=e,t},P.toExponential=function(t,e){var r=this,n=r.c[0];if(t!==UNDEFINED){if(t!==~~t||t<0||t>MAX_DP)throw Error(INVALID_DP);for(r=round(new r.constructor(r),++t,e);r.c.length<t;)r.c.push(0)}return stringify(r,!0,!!n)},P.toFixed=function(t,e){var r=this,n=r.c[0];if(t!==UNDEFINED){if(t!==~~t||t<0||t>MAX_DP)throw Error(INVALID_DP);for(t=t+(r=round(new r.constructor(r),t+r.e+1,e)).e+1;r.c.length<t;)r.c.push(0)}return stringify(r,!1,!!n)},P[Symbol.for("nodejs.util.inspect.custom")]=P.toJSON=P.toString=function(){var t=this,e=t.constructor;return stringify(t,t.e<=e.NE||t.e>=e.PE,!!t.c[0])},P.toNumber=function(){var t=Number(stringify(this,!0,!0));if(!0===this.constructor.strict&&!this.eq(t.toString()))throw Error(NAME+"Imprecise conversion");return t},P.toPrecision=function(t,e){var r=this,n=r.constructor,i=r.c[0];if(t!==UNDEFINED){if(t!==~~t||t<1||t>MAX_DP)throw Error(INVALID+"precision");for(r=round(new n(r),t,e);r.c.length<t;)r.c.push(0)}return stringify(r,t<=r.e||r.e<=n.NE||r.e>=n.PE,!!i)},P.valueOf=function(){var t=this,e=t.constructor;if(!0===e.strict)throw Error(NAME+"valueOf disallowed");return stringify(t,t.e<=e.NE||t.e>=e.PE,!0)};var Big=_Big_();
/**
 * [BaseEx|BasePhi Converter]{@link https://github.com/UmamiAppearance/BaseExJS/blob/main/src/converters/base-phi.js}
 *
 * @version 0.5.0
 * @author UmamiAppearance [mail@umamiappearance.eu]
 * @license GPL-3.0
 */class BasePhi extends BaseTemplate{#n=Big("1.618033988749894848204586834365638117720309179805762862135448622705260462818902449707207204189391137484754088075386891752");constructor(...t){super(),this.converter={radix:2,bsEnc:0,bsDec:0},this.b10=new BaseConverter(10,0,0),this.charsets.default=["0","1"],this.version="default",this.signed=!0,this.utils.validateArgs(t,!0),this.isMutable.integrity=!1}encode(t,...e){const r=this.utils.validateArgs(e),n=this.charsets[r.version];let i,s,o,a="";if(r.decimalMode){if(!Number.isFinite(t))throw new TypeError("When running the converter in 'decimalMode' only input of type Number is allowed.");t<0?(s=!0,o=Big(-t)):(s=!1,o=Big(t))}else[i,s]=this.utils.inputHandler.toBytes(t,r),o=Big(this.b10.encode(i,null,r.littleEndian)[0]);if(o.eq(0)||o.eq(1))return a=n[o.toNumber()],s&&(a=`-${a}`),a;const u=[],h=[];let l=Big(1),c=this.#n,f=0;for(;c.lt(o);)[l,c]=this.#i(l,c),f++;const p=(t,e,r)=>{if(this.#s(o))console.warn(0);else{for(;t.gt(o);){if([t,e]=this.#o(t,e),t.lte(0))return void console.warn("below 0");r--}r>-1?u.unshift(r):h.push(r),o=o.minus(t),p(t,e,r)}};return p(l,c,f),f=0,u.forEach((t=>{for(;f<t;)a=`${n[0]}${a}`,f++;a=`${n[1]}${a}`,f++})),a?a+=".":a="0.",f=-1,h.forEach((t=>{for(;f>t;)a+=n[0],f--;a+=n[1],f--})),s&&(a=`-${a}`),a}decode(t,...e){const r=this.utils.validateArgs(e),n=this.charsets[r.version];let i;[t,i]=this.utils.extractSign(this.utils.normalizeInput(t));const[s,o]=t.split(".");let a=Big(0),u=this.#n.minus(1),h=Big(1);if([...s].reverse().forEach((t=>{const e=n.indexOf(t);if(1===e)a=a.plus(h);else if(0!==e)throw new CharsetError(t);[u,h]=this.#i(u,h)})),o){let t=Big(1);h=this.#n.minus(t),[...o].forEach((e=>{const r=n.indexOf(e);if(1===r)a=a.plus(h);else if(0!==r)throw new CharsetError(e);[h,t]=this.#o(h,t)}))}if(r.decimalMode)return a.toNumber();a=a.round().toFixed();const l=this.b10.decode(a,[..."0123456789"],[],r.integrity,r.littleEndian);return this.utils.outputHandler.compile(l,r.outputType,r.littleEndian,i)}#s(t){return!t.round(50).abs().toNumber()}#i(t,e){return[e,t.plus(e)]}#o(t,e){return[e.minus(t),t]}}export{BasePhi as default};
