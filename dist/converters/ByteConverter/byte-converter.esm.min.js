class SmartInput{static makeDataView(t){const e=new ArrayBuffer(t);return new DataView(e)}static floatingPoints(t,e=!1){const n=this.makeDataView(8);return n.setFloat64(0,t,e),n}static numbers(t,e=!1){let n,i;if(Number.isInteger(t)){if(i="int",!Number.isSafeInteger(t)){let e,n,i;throw t<0?(e=Number.MIN_SAFE_INTEGER,n="smaller",i="MIN"):(e=Number.MAX_SAFE_INTEGER,n="bigger",i="MAX"),new RangeError(`The provided integer is ${n} than ${i}_SAFE_INTEGER: '${e}'\nData integrity is not guaranteed. Use a BigInt to avoid this issue.\n(If you see this error although a float was provided, the input has to many digits before the decimal point to store the decimal places in a float with 64 bits.)`)}t<0?t<-2147483648?(n=this.makeDataView(8),n.setBigInt64(0,BigInt(t),e)):t<-32768?(n=this.makeDataView(4),n.setInt32(0,t,e)):(n=this.makeDataView(2),n.setInt16(0,t,e)):t>0?t>4294967295?(n=this.makeDataView(8),n.setBigUint64(0,BigInt(t),e)):t>65535?(n=this.makeDataView(4),n.setUint32(0,t,e)):(n=this.makeDataView(2),n.setInt16(0,t,e)):n=new Uint16Array([0])}else i="float",n=this.floatingPoints(t,e);return[new Uint8Array(n.buffer),i]}static bigInts(t,e=!1){const n=new Array,i=e?"push":"unshift",r=18446744073709551616n;if(t<0)for(;t<-9223372036854775808n;)n[i](t%r),t>>=64n;else for(;t>=r;)n[i](t%r),t>>=64n;n[i](t);const a=8*n.length,s=this.makeDataView(a);return n.forEach(((t,n)=>{const i=8*n;s.setBigUint64(i,t,e)})),new Uint8Array(s.buffer)}static toBytes(t,e){let n,i=!1,r="bytes";if(t instanceof ArrayBuffer)n=new Uint8Array(t.slice());else if(ArrayBuffer.isView(t))n=new Uint8Array(t.buffer.slice());else if("string"==typeof t||t instanceof String)n=(new TextEncoder).encode(t);else if("number"==typeof t){if(isNaN(t))throw new TypeError("Cannot proceed. Input is NaN.");if(t==1/0)throw new TypeError("Cannot proceed. Input is Infinity.");if(e.signed&&t<0&&(i=!0,t=-t),e.numberMode){const i=this.floatingPoints(t,e.littleEndian);n=new Uint8Array(i.buffer),r="float"}else[n,r]=this.numbers(t,e.littleEndian)}else if("bigint"==typeof t)e.signed&&t<0&&(i=!0,t*=-1n),n=this.bigInts(t,e.littleEndian),r="int";else{if(!Array.isArray(t))throw new TypeError("The provided input type can not be processed.");{const i=new Array;for(const n of t)i.push(...this.toBytes(n,e)[0]);n=Uint8Array.from(i)}}return[n,i,r]}}class SmartOutput{static get typeList(){return["bigint64","bigint_n","biguint64","buffer","bytes","float32","float64","float_n","int8","int16","int32","int_n","str","uint8","uint16","uint32","uint_n","view"]}static getType(t){if(!this.typeList.includes(t))throw new TypeError(`Unknown output type: '${t}'`);return t}static makeTypedArrayBuffer(t,e,n,i){const r=t.byteLength,a=(e-t.byteLength%e)%e,s=i&&r>1?255:0;let o=t;if(a){o=new Uint8Array(r+a),o.fill(s);const e=n?0:a;o.set(t,e)}return o.buffer}static makeTypedArray(t,e,n,i){let r;if("int16"===e||"uint16"===e){const a=this.makeTypedArrayBuffer(t,2,n,i);r="int16"===e?new Int16Array(a):new Uint16Array(a)}else if("int32"===e||"uint32"===e||"float32"===e){const a=this.makeTypedArrayBuffer(t,4,n,i);r="int32"===e?new Int32Array(a):"uint32"===e?new Uint32Array(a):new Float32Array(a)}else if("bigint64"===e||"biguint64"===e||"float64"===e){const a=this.makeTypedArrayBuffer(t,8,n,i);r="bigint64"===e?new BigInt64Array(a):"biguint64"===e?new BigUint64Array(a):new Float64Array(a)}return r}static compile(t,e,n=!1,i=!1){let r;if(e=this.getType(e),i){let i;if(i=e.match(/^float/)?-this.compile(t,"float_n",n):-this.compile(t,"uint_n",n),"float_n"===e)return i;t=SmartInput.toBytes(i,{littleEndian:n,numberMode:!1,signed:!1})[0]}if("buffer"===e)r=t.buffer;else if("bytes"===e||"uint8"===e)r=t;else if("int8"===e)r=new Int8Array(t.buffer);else if("view"===e)r=new DataView(t.buffer);else if("str"===e)r=(new TextDecoder).decode(t);else if("uint_n"===e||"int_n"===e||"bigint_n"===e){if(1===t.length){const e=this.makeTypedArrayBuffer(t,2,n,i);t=new Uint8Array(e)}n&&t.reverse();let a=0n;t.forEach((t=>a=(a<<8n)+BigInt(t))),"uint_n"!==e&&(a=BigInt.asIntN(8*t.length,a)),r="bigint_n"!==e&&a>=Number.MIN_SAFE_INTEGER&&a<=Number.MAX_SAFE_INTEGER?Number(a):a}else if("float_n"===e)if(t.length<=4){let e;e=4===t.length?t:this.makeTypedArray(t,"float32",!1,i);r=new DataView(e.buffer).getFloat32(0,n)}else{if(!(t.length<=8))throw new RangeError("The provided input is to complex to be converted into a floating point.");{let e;e=8===t.length?t:this.makeTypedArray(t,"float64",!1,i);r=new DataView(e.buffer).getFloat64(0,n)}}else if("number"===e){if(8!==t.length)throw new TypeError("Type mismatch. Cannot convert into number.");const e=new Float64Array(t.buffer);r=Number(e)}else r=this.makeTypedArray(t,e,n,i);return r}}
/**
 * [BaseEx|Byte Converter]{@link https://github.com/UmamiAppearance/BaseExJS/blob/main/src/converters/byte-converter.js}
 *
 * @version 0.5.0
 * @author UmamiAppearance [mail@umamiappearance.eu]
 * @license GPL-3.0
 */const LITTLE_ENDIAN=(()=>{const t=new Uint16Array([1]),e=new Uint8Array(t.buffer);return Boolean(e.at(0))})();class ByteConverter{constructor(...t){this.littleEndian=LITTLE_ENDIAN,this.numberMode=!1,this.outputType="buffer",this.utils={validateArgs:(t,e=!1)=>{const n={littleEndian:this.littleEndian,numberMode:this.numberMode,outputType:this.outputType,signed:!1};if(!t.length)return n;t.includes("number")&&(t.splice(t.indexOf("number"),1),n.numberMode=!0,n.outputType="float_n");const i=SmartOutput.typeList.map((t=>`'${t}'`)).join(", ");if(t.forEach((t=>{if("le"===(t=String(t).toLowerCase()))n.littleEndian=!0;else if("be"===t)n.littleEndian=!1;else{if(!SmartOutput.typeList.includes(t))throw new TypeError(`Invalid argument: '${t}.\nValid arguments are:\n'le', 'be', ${i}`);n.outputType=t}})),e)for(const t in n)this[t]=n[t];return n}},this.utils.validateArgs(t,!0)}encode(t,...e){const n=this.utils.validateArgs(e);return SmartInput.toBytes(t,n)[0]}decode(t,...e){const n=this.utils.validateArgs(e);return SmartOutput.compile(t,n.outputType,n.littleEndian)}}export{ByteConverter as default};
