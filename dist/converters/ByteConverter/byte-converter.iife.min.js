var ByteConverter=function(e){"use strict";class t{static makeDataView(e){const t=new ArrayBuffer(e);return new DataView(t)}static floatingPoints(e,n=!1){const i=t.makeDataView(8);return i.setFloat64(0,e,n),i}static numbers(e,n=!1){let i,r;if(Number.isInteger(e)){if(r="int",!Number.isSafeInteger(e)){let t,n,i;throw e<0?(t=Number.MIN_SAFE_INTEGER,n="smaller",i="MIN"):(t=Number.MAX_SAFE_INTEGER,n="bigger",i="MAX"),new RangeError(`The provided integer is ${n} than ${i}_SAFE_INTEGER: '${t}'\nData integrity is not guaranteed. Use a BigInt to avoid this issue.\n(If you see this error although a float was provided, the input has to many digits before the decimal point to store the decimal places in a float with 64 bits.)`)}e<0?e<-2147483648?(i=t.makeDataView(8),i.setBigInt64(0,BigInt(e),n)):e<-32768?(i=t.makeDataView(4),i.setInt32(0,e,n)):(i=t.makeDataView(2),i.setInt16(0,e,n)):e>0?e>4294967295?(i=t.makeDataView(8),i.setBigUint64(0,BigInt(e),n)):e>65535?(i=t.makeDataView(4),i.setUint32(0,e,n)):(i=t.makeDataView(2),i.setInt16(0,e,n)):i=new Uint16Array([0])}else r="float",i=t.floatingPoints(e,n);return[new Uint8Array(i.buffer),r]}static bigInts(e,n=!1){const i=new Array,r=n?"push":"unshift",a=18446744073709551616n;if(e<0)for(;e<-9223372036854775808n;)i[r](e%a),e>>=64n;else for(;e>=a;)i[r](e%a),e>>=64n;i[r](e);const s=8*i.length,o=t.makeDataView(s);return i.forEach(((e,t)=>{const i=8*t;o.setBigUint64(i,e,n)})),new Uint8Array(o.buffer)}static toBytes(e,n){let i,r=!1,a="bytes";if(e instanceof ArrayBuffer)i=new Uint8Array(e);else if(ArrayBuffer.isView(e))i=new Uint8Array(e.buffer);else if("string"==typeof e||e instanceof String)i=(new TextEncoder).encode(e);else if("number"==typeof e){if(isNaN(e))throw new TypeError("Cannot proceed. Input is NaN.");if(e==1/0)throw new TypeError("Cannot proceed. Input is Infinity.");if(n.signed&&e<0&&(r=!0,e=-e),n.numberMode){const r=t.floatingPoints(e,n.littleEndian);i=new Uint8Array(r.buffer),a="float"}else[i,a]=t.numbers(e,n.littleEndian)}else if("bigint"==typeof e)n.signed&&e<0&&(r=!0,e*=-1n),i=t.bigInts(e,n.littleEndian),a="int";else{if(!Array.isArray(e))throw new TypeError("The provided input type can not be processed.");{const n=new Array;for(const i of e)n.push(...t.toBytes(i));i=Uint8Array.from(n)}}return[i,r,a]}}class n{static get typeList(){return["bigint64","bigint_n","biguint64","buffer","bytes","float32","float64","float_n","int8","int16","int32","int_n","str","uint8","uint16","uint32","uint_n","view"]}static getType(e){if(!n.typeList.includes(e))throw new TypeError(`Unknown output type: '${e}'`);return e}static makeTypedArrayBuffer(e,t,n){const i=e.byteLength,r=(t-e.byteLength%t)%t;let a=e;if(r){a=new Uint8Array(i+r);const t=n?r:0;a.set(e,t)}return a.buffer}static makeTypedArray(e,t,i){let r;if("int16"===t||"uint16"===t){const a=n.makeTypedArrayBuffer(e,2,i);r="int16"===t?new Int16Array(a):new Uint16Array(a)}else if("int32"===t||"uint32"===t||"float32"===t){const a=n.makeTypedArrayBuffer(e,4,i);r="int32"===t?new Int32Array(a):"uint32"===t?new Uint32Array(a):new Float32Array(a)}else if("bigint64"===t||"biguint64"===t||"float64"===t){const a=n.makeTypedArrayBuffer(e,8,i);r="bigint64"===t?new BigInt64Array(a):"biguint64"===t?new BigUint64Array(a):new Float64Array(a)}return r}static compile(e,t,i=!1,r=!1){let a;if("buffer"===(t=n.getType(t)))a=e.buffer;else if("bytes"===t||"uint8"===t)a=e;else if("int8"===t)a=new Int8Array(e.buffer);else if("view"===t)a=new DataView(e.buffer);else if("str"===t)a=(new TextDecoder).decode(e);else if("uint_n"===t||"int_n"===t||"bigint_n"===t){i&&e.reverse();let n=0n;e.forEach((e=>n=(n<<8n)+BigInt(e))),"int_n"===t&&(n=BigInt.asIntN(8*e.length,n)),a="bigint_n"!==t&&n>=Number.MIN_SAFE_INTEGER&&n<=Number.MAX_SAFE_INTEGER?Number(n):n,r&&(a=-a)}else if("float_n"===t)if(e.length<=4){let t;t=4===e.length?e:n.makeTypedArray(e,"float32",!1);a=new DataView(t.buffer).getFloat32(0,i)}else{if(!(e.length<=8))throw new RangeError("The provided input is to complex to be converted into a floating point.");{let t;t=8===e.length?e:n.makeTypedArray(e,"float64",!1);a=new DataView(t.buffer).getFloat64(0,i)}}else if("number"===t){if(8!==e.length)throw new TypeError("Type mismatch. Cannot convert into number.");const t=new Float64Array(e.buffer);a=Number(t)}else a=n.makeTypedArray(e,t,i);return a}}return e.ByteConverter=class{constructor(){this.converter={encode:t.toBytes,decode:n.compile},this.littleEndian=!0,this.numberMode=!1,this.outputType="buffer",this.utils={validateArgs:(e,t=!1)=>{const i={littleEndian:this.littleEndian,numberMode:this.numberMode,outputType:this.outputType,signed:!1};if(!e.length)return i;e.includes("number")&&(e.splice(e.indexOf("number"),1),i.numberMode=!0,i.outputType="float_n");const r=n.typeList.map((e=>`'${e}'`)).join(", ");if(e.forEach((e=>{if("le"===(e=String(e).toLowerCase()))i.littleEndian=!0;else if("be"===e)i.littleEndian=!1;else{if(!n.typeList.includes(e))throw new TypeError(`Invalid argument: '${e}.\nValid arguments are:\n'le', 'be', ${r}`);i.outputType=e}})),t)for(const e in i)this.root[e]=i[e];return i}}}encode(e,...t){const n=this.utils.validateArgs(t);return this.converter.encode(e,n)[0]}decode(e,...t){const n=this.utils.validateArgs(t);return this.converter.decode(e,n.outputType,n.littleEndian)}},Object.defineProperty(e,"__esModule",{value:!0}),e}({});
