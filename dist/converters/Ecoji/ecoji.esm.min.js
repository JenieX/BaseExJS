class BytesInput{static toBytes(t){return ArrayBuffer.isView(t)&&(t=t.buffer),[new Uint8Array(t),!1,"bytes"]}}class BytesOutput{static get typeList(){return["buffer","bytes","uint8","view"]}static getType(t){if(!BytesOutput.typeList.includes(t))throw new TypeError(`Unknown output type: '${t}'`);return t}static compile(t,e){let i;return i="buffer"===(e=BytesOutput.getType(e))?t.buffer:"view"===e?new DataView(t.buffer):t,i}}class SmartInput{static makeDataView(t){const e=new ArrayBuffer(t);return new DataView(e)}static floatingPoints(t,e=!1){const i=this.makeDataView(8);return i.setFloat64(0,t,e),i}static numbers(t,e=!1){let i,r;if(Number.isInteger(t)){if(r="int",!Number.isSafeInteger(t)){let e,i,r;throw t<0?(e=Number.MIN_SAFE_INTEGER,i="smaller",r="MIN"):(e=Number.MAX_SAFE_INTEGER,i="bigger",r="MAX"),new RangeError(`The provided integer is ${i} than ${r}_SAFE_INTEGER: '${e}'\nData integrity is not guaranteed. Use a BigInt to avoid this issue.\n(If you see this error although a float was provided, the input has to many digits before the decimal point to store the decimal places in a float with 64 bits.)`)}t<0?t<-2147483648?(i=this.makeDataView(8),i.setBigInt64(0,BigInt(t),e)):t<-32768?(i=this.makeDataView(4),i.setInt32(0,t,e)):(i=this.makeDataView(2),i.setInt16(0,t,e)):t>0?t>4294967295?(i=this.makeDataView(8),i.setBigUint64(0,BigInt(t),e)):t>65535?(i=this.makeDataView(4),i.setUint32(0,t,e)):(i=this.makeDataView(2),i.setInt16(0,t,e)):i=new Uint16Array([0])}else r="float",i=this.floatingPoints(t,e);return[new Uint8Array(i.buffer),r]}static bigInts(t,e=!1){const i=new Array,r=e?"push":"unshift",n=18446744073709551616n;if(t<0)for(;t<-9223372036854775808n;)i[r](t%n),t>>=64n;else for(;t>=n;)i[r](t%n),t>>=64n;i[r](t);const s=8*i.length,o=this.makeDataView(s);return i.forEach(((t,i)=>{const r=8*i;o.setBigUint64(r,t,e)})),new Uint8Array(o.buffer)}static toBytes(t,e){let i,r=!1,n="bytes";if(t instanceof ArrayBuffer)i=new Uint8Array(t.slice());else if(ArrayBuffer.isView(t))i=new Uint8Array(t.buffer.slice());else if("string"==typeof t||t instanceof String)i=(new TextEncoder).encode(t);else if("number"==typeof t){if(isNaN(t))throw new TypeError("Cannot proceed. Input is NaN.");if(t==1/0)throw new TypeError("Cannot proceed. Input is Infinity.");if(e.signed&&t<0&&(r=!0,t=-t),e.numberMode){const r=this.floatingPoints(t,e.littleEndian);i=new Uint8Array(r.buffer),n="float"}else[i,n]=this.numbers(t,e.littleEndian)}else if("bigint"==typeof t)e.signed&&t<0&&(r=!0,t*=-1n),i=this.bigInts(t,e.littleEndian),n="int";else{if(!Array.isArray(t))throw new TypeError("The provided input type can not be processed.");{const r=new Array;for(const i of t)r.push(...this.toBytes(i,e)[0]);i=Uint8Array.from(r)}}return[i,r,n]}}class SmartOutput{static get typeList(){return["bigint64","bigint_n","biguint64","buffer","bytes","float32","float64","float_n","int8","int16","int32","int_n","str","uint8","uint16","uint32","uint_n","view"]}static getType(t){if(!this.typeList.includes(t))throw new TypeError(`Unknown output type: '${t}'`);return t}static makeTypedArrayBuffer(t,e,i,r){const n=t.byteLength,s=(e-t.byteLength%e)%e,o=r&&n>1?255:0;let a=t;if(s){a=new Uint8Array(n+s),a.fill(o);const e=i?0:s;a.set(t,e)}return a.buffer}static makeTypedArray(t,e,i,r){let n;if("int16"===e||"uint16"===e){const s=this.makeTypedArrayBuffer(t,2,i,r);n="int16"===e?new Int16Array(s):new Uint16Array(s)}else if("int32"===e||"uint32"===e||"float32"===e){const s=this.makeTypedArrayBuffer(t,4,i,r);n="int32"===e?new Int32Array(s):"uint32"===e?new Uint32Array(s):new Float32Array(s)}else if("bigint64"===e||"biguint64"===e||"float64"===e){const s=this.makeTypedArrayBuffer(t,8,i,r);n="bigint64"===e?new BigInt64Array(s):"biguint64"===e?new BigUint64Array(s):new Float64Array(s)}return n}static compile(t,e,i=!1,r=!1){let n;if(e=this.getType(e),r){let r;if(r=e.match(/^float/)?-this.compile(t,"float_n",i):-this.compile(t,"uint_n",i),"float_n"===e)return r;t=SmartInput.toBytes(r,{littleEndian:i,numberMode:!1,signed:!1})[0]}if("buffer"===e)n=t.buffer;else if("bytes"===e||"uint8"===e)n=t;else if("int8"===e)n=new Int8Array(t.buffer);else if("view"===e)n=new DataView(t.buffer);else if("str"===e)n=(new TextDecoder).decode(t);else if("uint_n"===e||"int_n"===e||"bigint_n"===e){if(1===t.length){const e=this.makeTypedArrayBuffer(t,2,i,r);t=new Uint8Array(e)}i&&t.reverse();let s=0n;t.forEach((t=>s=(s<<8n)+BigInt(t))),"uint_n"!==e&&(s=BigInt.asIntN(8*t.length,s)),n="bigint_n"!==e&&s>=Number.MIN_SAFE_INTEGER&&s<=Number.MAX_SAFE_INTEGER?Number(s):s}else if("float_n"===e)if(t.length<=4){let e;e=4===t.length?t:this.makeTypedArray(t,"float32",!1,r);n=new DataView(e.buffer).getFloat32(0,i)}else{if(!(t.length<=8))throw new RangeError("The provided input is to complex to be converted into a floating point.");{let e;e=8===t.length?t:this.makeTypedArray(t,"float64",!1,r);n=new DataView(e.buffer).getFloat64(0,i)}}else if("number"===e){if(8!==t.length)throw new TypeError("Type mismatch. Cannot convert into number.");const e=new Float64Array(t.buffer);n=Number(e)}else n=this.makeTypedArray(t,e,i,r);return n}}const DEFAULT_INPUT_HANDLER=SmartInput,DEFAULT_OUTPUT_HANDLER=SmartOutput;class SignError extends TypeError{constructor(){super("The input is signed but the converter is not set to treat input as signed.\nYou can pass the string 'signed' to the decode function or when constructing the converter."),this.name="SignError"}}class CharsetError extends TypeError{constructor(t){super(`Invalid input. Character: '${t}' is not part of the charset.`),this.name="CharsetError"}}class Utils{constructor(t){this.root=t,this.converterArgs={},this.#t()}setIOHandlers(t=DEFAULT_INPUT_HANDLER,e=DEFAULT_OUTPUT_HANDLER){this.inputHandler=t,this.outputHandler=e}#t(){this.root.addCharset=(t,e,i=[],r=!0)=>{const n=(t,i,r)=>{if(0===r&&i.length)return console.warn(`This converter has no ${t}. The following argument was ignored:\n'${i}'`),[];let n=r;if("string"==typeof i&&(i=[...i]),Array.isArray(i))n=i.length,i=new Set(i);else if(!(i instanceof Set))throw new TypeError(`The ${t} must be one of the types:\n'str', 'set', 'array'."`);if(i.size===r)return[...i];if(n!==r)throw new Error(`Your ${t} has a length of ${n}. The converter requires a length of ${r}.`);{const i={};(e=[...e]).forEach((t=>{t in i?i[t]++:i[t]=1}));let n="";r<100&&(n=`${e.join("")}\n`,e.forEach((t=>{i[t]>1?n+="^":n+=" "})));const s=Object.keys(i).filter((t=>i[t]>1));throw new Error(`You have repetitive char(s) [ ${s.join(" | ")} ] in your ${t}. Make sure each character is unique.\n${n}`)}};if(this.root.frozenCharsets)throw new Error("The charsets of this converter cannot be changed.");if("string"!=typeof t)throw new TypeError("The charset name must be a string.");r&&t in this.root.charsets&&console.warn(`An existing charset with name ${t} will get replaced.`);const s=n("charset",e,this.root.converter.radix),o=n("padding set",i,this.root.padCharAmount);this.root.charsets[t]=s,o.length&&(this.root.padChars[t]=o),r&&console.info(`New charset '${t}' was added and is ready to use`)},this.root.setDefaultCharset=t=>{if(!(t in this.root.charsets)){const e=Object.keys(this.root.charsets).join("\n   * ");throw new TypeError(`Charset ${t} was not found. Available charsets are:\n   * ${e}`)}this.root.version=t}}#e(t){return t.map((t=>`'${t}'`)).join(", ")}toSignedStr(t,e){return t=t.replace(/^0+(?!$)/,""),e&&(t="-".concat(t)),t}extractSign(t){let e=!1;return"-"===t[0]&&(e=!0,t=t.slice(1)),[t,e]}#i(t,e,i,r){const n=r?"\n * valid declarations for IO handlers are 'bytesOnly', 'bytesIn', 'bytesOut'":"",s=this.root.isMutable.signed?"\n * pass 'signed' to disable, 'unsigned' to enable the use of the twos's complement for negative integers":"",o=this.root.isMutable.littleEndian?"\n * 'be' for big , 'le' for little endian byte order for case conversion":"",a=this.root.isMutable.padding?"\n * pass 'pad' to fill up, 'nopad' to not fill up the output with the particular padding":"",h=this.root.isMutable.upper?"\n * valid args for changing the encoded output case are 'upper' and 'lower'":"",l=`\n * valid args for the output type are ${this.#e(i)}`,u=e?`\n * the option(s) for version/charset are: ${this.#e(e)}`:"",c=Object.keys(this.converterArgs).length?`\n * converter specific args:\n   - ${(()=>Object.keys(this.converterArgs).map((t=>this.converterArgs[t].map((t=>`'${t}'`)).join(" and "))).join("\n   - "))()}`:"";throw new TypeError(`'${t}'\n\nParameters:${n}${s}${o}${a}${h}${l}${u}\n * valid args for integrity check are: 'integrity' and 'nointegrity'\n * 'number' for number-mode (converts every number into a Float64Array to keep the natural js number type)${c}\n\nTraceback:`)}validateArgs(t,e=!1){const i={integrity:this.root.integrity,littleEndian:this.root.littleEndian,numberMode:this.root.numberMode,options:this.root.options,outputType:this.root.outputType,padding:this.root.padding,signed:this.root.signed,upper:this.root.upper,version:this.root.version};for(const t in this.converterArgs)i[t]=this.root[t];if(!t.length)return e&&this.setIOHandlers(),i;const r=e=>!!t.includes(e)&&(t.splice(t.indexOf(e),1),!0),n=Object.keys(this.root.charsets),s={integrity:["nointegrity","integrity"],littleEndian:["be","le"],padding:["nopad","pad"],signed:["unsigned","signed"],upper:["lower","upper"],...this.converterArgs};if(e)if(r("bytes_only"))this.setIOHandlers(BytesInput,BytesOutput);else{const t=r("bytes_in")?BytesInput:DEFAULT_INPUT_HANDLER,e=r("bytes_out")?BytesOutput:DEFAULT_OUTPUT_HANDLER;this.setIOHandlers(t,e)}const o=this.outputHandler.typeList;if(r("number")&&(i.numberMode=!0,i.outputType="float_n"),t.forEach((t=>{if("object"!=typeof t)if(t=String(t).toLowerCase(),n.includes(t))i.version=t;else if(o.includes(t))i.outputType=t;else{let r=!0;for(const e in s)if(s[e].includes(t)){if(r=!1,!this.root.isMutable[e])throw TypeError(`Argument '${t}' is not allowed for this type of converter.`);i[e]=Boolean(s[e].indexOf(t))}r&&this.#i(t,n,o,e)}else i.options={...i.options,...t}})),i.padding&&i.signed&&(i.padding=!1,console.warn("Padding was set to false due to the signed conversion.")),e)for(const t in i)this.root[t]=i[t];return i}signError(){throw new SignError}wrapOutput(t,e=0){if(!e)return t;const i=new RegExp(`.{1,${e}}`,"gu");return t.match(i).join("\n")}normalizeInput(t,e=!1){return e?String(t):String(t).replace(/\n/g,"")}}class BaseConverter{constructor(t,e=null,i=null,r=0){this.radix=t,null!==e&&null!==i?(this.bsEnc=e,this.bsDec=i):[this.bsEnc,this.bsDec]=this.constructor.guessBS(t),this.decPadVal=r}static guessBS(t){let e=t<8?t:Math.ceil(256/t);for(;e>8&&!(e%8);)e/=8;let i=0;for(;8*i*Math.log(2)/Math.log(t)<e;)i++;return[i,Math.ceil(8*i*Math.log(2)/Math.log(t))]}encode(t,e,i=!1,r=null){let n=this.bsEnc;0===n&&(n=t.byteLength);let s="";const o=n?(n-t.length%n)%n:0,a=new Array(o).fill(0);let h;if(i?(t.reverse(),h=[...a,...t]):h=[...t,...a],10===this.radix){let t=0n;for(let e=0;e<n;e++)t=(t<<8n)+BigInt(h[e]);return[t.toString(),0]}for(let t=0,i=h.length;t<i;t+=n){let i=0n;for(let e=t;e<t+n;e++)i=(i<<8n)+BigInt(h[e]);const a=new Array;let l,u=i;for(;u>=this.radix;)[u,l]=this.divmod(u,this.radix),a.unshift(parseInt(l,10));for(a.unshift(parseInt(u,10));a.length<this.bsDec;)a.unshift(0);let c="";a.forEach((t=>c=c.concat(e[t]))),r&&(c=r(c,o)),s=s.concat(c)}return[s,o]}decode(t,e,i=[],r=!0,n=!1){if(!t)return new Uint8Array(0);let s=this.bsDec;const o=new Array;let a;if([...t].forEach((t=>{const n=e.indexOf(t);if(n>-1)o.push(n);else if(r&&-1===i.indexOf(t))throw new CharsetError(t)})),0===s)s=o.length;else{a=(s-o.length%s)%s;const t=new Array(a).fill(this.decPadVal);n?o.unshift(...t):o.push(...t)}let h=new Array;for(let t=0,e=o.length;t<e;t+=s){let e=0n;for(let i=0;i<s;i++)e+=BigInt(o[t+i])*this.pow(s-1-i);const i=new Array;let r,n=e;for(;n>=256;)[n,r]=this.divmod(n,256),i.unshift(parseInt(r,10));for(i.unshift(parseInt(n,10));i.length<this.bsEnc;)i.unshift(0);h=h.concat(i)}if(n){if(h.length>1){for(;!h[0];)h.shift();h.length||h.push(0),h.reverse()}}else if(this.bsDec){const t=this.padChars(a);h.splice(h.length-t)}return Uint8Array.from(h)}padBytes(t){return Math.floor(t*this.bsDec/this.bsEnc)}padChars(t){return Math.ceil(t*this.bsEnc/this.bsDec)}pow(t){return BigInt(this.radix)**BigInt(t)}divmod(t,e){return[t,e]=[BigInt(t),BigInt(e)],[t/e,t%e]}}class BaseTemplate{constructor(t=!0){this.charsets={},this.frozenCharsets=!1,this.hasSignedMode=!1,this.integrity=!0,this.littleEndian=!1,this.numberMode=!1,this.outputType="buffer",this.padding=!1,this.padCharAmount=0,this.padChars={},this.signed=!1,this.upper=null,t&&(this.utils=new Utils(this)),this.version="default",this.options={lineWrap:0},this.isMutable={integrity:!0,littleEndian:!1,padding:!1,signed:!1,upper:!1}}encode(t,e,i,...r){const n=this.utils.validateArgs(r);let[s,o,a]=this.utils.inputHandler.toBytes(t,n),h=null;e&&(h=e(n));let[l,u]=this.converter.encode(s,this.charsets[n.version],n.littleEndian,h);return n.signed&&(l=this.utils.toSignedStr(l,o)),n.upper&&(l=l.toUpperCase()),i&&(l=i({inputBytes:s,output:l,settings:n,zeroPadding:u,type:a})),this.utils.wrapOutput(l,n.options.lineWrap)}decode(t,e,i,r,...n){const s=this.utils.validateArgs(n);t=this.utils.normalizeInput(t,r);let o=!1;this.hasSignedMode&&([t,o]=this.utils.extractSign(t),o&&!s.signed&&this.utils.signError()),this.isMutable.upper&&(t=t.toLowerCase()),e&&(t=e({input:t,settings:s}));let a=this.converter.decode(t,this.charsets[s.version],this.padChars[s.version],s.integrity,s.littleEndian);return i&&(a=i({input:t,output:a,settings:s})),this.utils.outputHandler.compile(a,s.outputType,s.littleEndian,o)}}
/**
 * [BaseEx|Ecoji Converter]{@link https://github.com/UmamiAppearance/BaseExJS/src/converters/ecoji.js}
 *
 * @version 0.5.0
 * @author UmamiAppearance [mail@umamiappearance.eu]
 * @license GPL-3.0 OR Apache-2.0
 * @see https://github.com/keith-turner/ecoji
 */class Ecoji extends BaseTemplate{#r={};#n=null;constructor(...t){super(),this.charsets.emojis_v1=[..."🀄🃏🅰🅱🅾🅿🆎🆑🆒🆓🆔🆕🆖🆗🆘🆙🆚🇦🇧🇨🇩🇪🇫🇬🇭🇮🇯🇰🇱🇲🇳🇴🇵🇶🇷🇸🇹🇺🇻🇼🇽🇾🇿🈁🈂🈚🈯🈲🈳🈴🈵🈶🈷🈸🈹🈺🉐🉑🌀🌁🌂🌃🌄🌅🌆🌇🌈🌉🌊🌋🌌🌍🌎🌏🌐🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜🌝🌞🌟🌠🌡🌤🌥🌦🌧🌨🌩🌪🌫🌬🌭🌮🌯🌰🌱🌲🌳🌴🌵🌶🌷🌸🌹🌺🌻🌼🌽🌾🌿🍀🍁🍂🍃🍄🍅🍆🍇🍈🍉🍊🍋🍌🍍🍎🍏🍐🍑🍒🍓🍔🍕🍖🍗🍘🍙🍚🍛🍜🍝🍞🍟🍠🍡🍢🍣🍤🍥🍦🍧🍨🍩🍪🍫🍬🍭🍮🍯🍰🍱🍲🍳🍴🍵🍶🍷🍸🍹🍺🍻🍼🍽🍾🍿🎀🎁🎂🎃🎄🎅🎆🎇🎈🎉🎊🎋🎌🎍🎎🎏🎐🎑🎒🎓🎖🎗🎙🎚🎛🎞🎟🎠🎡🎢🎣🎤🎥🎦🎧🎨🎩🎪🎫🎬🎭🎮🎯🎰🎱🎲🎳🎴🎵🎶🎷🎸🎹🎺🎻🎼🎽🎾🎿🏀🏁🏂🏃🏄🏅🏆🏇🏈🏉🏊🏋🏌🏎🏏🏐🏑🏒🏓🏔🏕🏖🏗🏘🏙🏚🏛🏜🏝🏞🏟🏠🏡🏢🏣🏤🏥🏦🏧🏨🏩🏪🏫🏬🏭🏮🏯🏰🏳🏴🏵🏷🏸🏹🏺🏻🏼🏽🏾🏿🐀🐁🐂🐃🐄🐅🐆🐇🐈🐉🐊🐋🐌🐍🐎🐏🐐🐑🐒🐓🐔🐕🐖🐗🐘🐙🐚🐛🐜🐝🐞🐟🐠🐡🐢🐣🐤🐥🐦🐧🐨🐩🐪🐫🐬🐭🐮🐯🐰🐱🐲🐳🐴🐵🐶🐷🐸🐹🐺🐻🐼🐽🐾🐿👀👁👂👃👄👅👆👇👈👉👊👋👌👍👎👏👐👑👒👓👔👕👖👗👘👙👚👛👜👝👞👟👠👡👢👣👤👥👦👧👨👩👪👫👬👭👮👯👰👱👲👳👴👵👶👷👸👹👺👻👼👽👾👿💀💁💂💃💄💅💆💇💈💉💊💋💌💍💎💏💐💑💒💓💔💕💖💗💘💙💚💛💜💝💞💟💠💡💢💣💤💥💦💧💨💩💪💫💬💭💮💯💰💱💲💳💴💵💶💷💸💹💺💻💼💽💾💿📀📁📂📃📄📅📆📇📈📉📊📋📌📍📎📏📐📒📓📔📕📖📗📘📙📚📛📜📝📞📟📠📡📢📣📤📥📦📧📨📩📪📫📬📭📮📯📰📱📲📳📴📵📶📷📸📹📺📻📼📽📿🔀🔁🔂🔃🔄🔅🔆🔇🔈🔉🔊🔋🔌🔍🔎🔏🔐🔑🔒🔓🔔🔕🔖🔗🔘🔙🔚🔛🔜🔝🔞🔟🔠🔡🔢🔣🔤🔥🔦🔧🔨🔩🔪🔫🔬🔭🔮🔯🔰🔱🔲🔳🔴🔵🔶🔷🔸🔹🔺🔻🔼🔽🕉🕊🕋🕌🕍🕎🕐🕑🕒🕓🕔🕕🕖🕗🕘🕙🕚🕛🕜🕝🕞🕟🕠🕡🕢🕣🕤🕥🕦🕧🕯🕰🕳🕴🕵🕶🕷🕸🕹🕺🖇🖊🖋🖌🖍🖐🖕🖖🖤🖥🖨🖱🖲🖼🗂🗃🗄🗑🗒🗓🗜🗝🗞🗡🗣🗨🗯🗳🗺🗻🗼🗽🗾🗿😀😁😂😃😄😅😆😇😈😉😊😋😌😍😎😏😐😑😒😓😔😕😖😗😘😙😚😛😜😝😞😟😠😡😢😣😤😥😦😧😨😩😪😫😬😭😮😯😰😱😲😳😴😵😶😷😸😹😺😻😼😽😾😿🙀🙁🙂🙃🙄🙅🙆🙇🙈🙉🙊🙌🙍🙎🙏🚀🚁🚂🚃🚄🚅🚆🚇🚈🚉🚊🚋🚌🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚙🚚🚛🚜🚝🚞🚟🚠🚡🚢🚣🚤🚥🚦🚧🚨🚩🚪🚫🚬🚭🚮🚯🚰🚱🚲🚳🚴🚵🚶🚷🚸🚹🚺🚻🚼🚽🚾🚿🛀🛁🛂🛃🛄🛅🛋🛌🛍🛎🛏🛐🛑🛒🛠🛡🛢🛣🛤🛥🛩🛫🛬🛰🛳🛴🛵🛶🛷🛸🛹🤐🤑🤒🤓🤔🤕🤖🤗🤘🤙🤚🤛🤜🤝🤞🤟🤠🤡🤢🤣🤤🤥🤦🤧🤨🤩🤪🤫🤬🤭🤮🤯🤰🤱🤲🤳🤴🤵🤶🤷🤸🤹🤺🤼🤽🤾🥀🥁🥂🥃🥄🥅🥇🥈🥉🥊🥋🥌🥍🥎🥏🥐🥑🥒🥓🥔🥕🥖🥗🥘🥙🥚🥛🥜🥝🥞🥟🥠🥡🥢🥣🥤🥥🥦🥧🥨🥩🥪🥫🥬🥭🥮🥯🥰🥳🥴🥵🥶🥺🥼🥽🥾🥿🦀🦁🦂🦃🦄🦅🦆🦇🦈🦉🦊🦋🦌🦍🦎🦏🦐🦑🦒🦓🦔🦕🦖🦗🦘🦙🦚🦛🦜🦝🦞🦟🦠🦡🦢🦰🦱🦲🦳🦴🦵🦶🦷🦸🦹🧀🧁🧂🧐🧑🧒🧓🧔🧕"],this.padChars.emojis_v1=["⚜","🏍","📑","🙋","☕"],this.charsets.emojis_v2=[..."🀄🃏⏰⏳☔♈♉♊♋♌♍♎♏♐♑♒♓♿⚓⚡⚽⚾⛄⛅⛎⛔⛪⛲⛳⛵⛺⛽✊✋✨⭐🛕🛖🛗🛝🛞🛟🛺🈁🛻🤌🤏🤿🥱🥲🥸🥹🥻🦣🦤🦥🦦🦧🌀🌁🌂🌃🌄🌅🌆🌇🌈🌉🌊🌋🌌🌍🌎🌏🌐🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜🌝🌞🌟🌠🦨🦩🦪🦫🦬🦭🦮🦯🦺🦻🌭🌮🌯🌰🌱🌲🌳🌴🌵🦼🌷🌸🌹🌺🌻🌼🌽🌾🌿🍀🍁🍂🍃🍄🍅🍆🍇🍈🍉🍊🍋🍌🍍🍎🍏🍐🍑🍒🍓🍔🍕🍖🍗🍘🍙🍚🍛🍜🍝🍞🍟🍠🍡🍢🍣🍤🍥🍦🍧🍨🍩🍪🍫🍬🍭🍮🍯🍰🍱🍲🍳🍴🍵🍶🍷🍸🍹🍺🍻🍼🦽🍾🍿🎀🎁🎂🎃🎄🎅🎆🎇🎈🎉🎊🎋🎌🎍🎎🎏🎐🎑🎒🎓🦾🦿🧃🧄🧅🧆🧇🎠🎡🎢🎣🎤🎥🧈🎧🎨🎩🎪🎫🎬🎭🎮🎯🎰🎱🎲🎳🎴🎵🎶🎷🎸🎹🎺🎻🎼🎽🎾🎿🏀🏁🏂🏃🏄🏅🏆🏇🏈🏉🏊🧉🧊🧋🏏🏐🏑🏒🏓🧌🧍🧎🧏🧖🧗🧘🧙🧚🧛🧜🧝🏠🏡🏢🏣🏤🏥🏦🧞🏨🏩🏪🏫🏬🏭🏮🏯🏰🧟🏴🧠🧢🏸🏹🏺🧣🧤🧥🧦🧧🐀🐁🐂🐃🐄🐅🐆🐇🐈🐉🐊🐋🐌🐍🐎🐏🐐🐑🐒🐓🐔🐕🐖🐗🐘🐙🐚🐛🐜🐝🐞🐟🐠🐡🐢🐣🐤🐥🐦🐧🐨🐩🐪🐫🐬🐭🐮🐯🐰🐱🐲🐳🐴🐵🐶🐷🐸🐹🐺🐻🐼🐽🐾🧨👀🧩👂👃👄👅👆👇👈👉👊👋👌👍👎👏👐👑👒👓👔👕👖👗👘👙👚👛👜👝👞👟👠👡👢👣👤👥👦👧👨👩👪👫👬👭👮👯👰👱👲👳👴👵👶👷👸👹👺👻👼👽👾👿💀💁💂💃💄💅💆💇💈💉💊💋💌💍💎💏💐💑💒💓💔💕💖💗💘💙💚💛💜💝💞💟💠💡💢💣💤💥💦💧💨💩💪💫💬💭💮💯💰💱💲💳💴💵💶💷💸🧪💺💻💼💽💾💿📀🧫📂📃📄🧬📆📇📈📉📊📋📌📍📎📏📐📒📓📔📕📖📗📘📙📚📛📜📝📞📟📠📡📢📣📤📥📦📧📨📩📪📫📬📭📮📯📰📱📲📳🧭📵📶📷📸📹📺📻📼🧮📿🧯🧰🧱🧲🧳🔅🔆🔇🔈🔉🔊🔋🔌🔍🔎🔏🔐🔑🔒🔓🔔🔕🔖🔗🔘🧴🧵🧶🧷🧸🧹🧺🧻🧼🧽🧾🧿🔥🔦🔧🔨🔩🔪🔫🔬🔭🔮🔯🔰🔱🔲🔳🩰🩱🩲🩳🩴🩸🩹🩺🩻🩼🪀🪁🕋🕌🕍🕎🪂🪃🪄🪅🪆🪐🪑🪒🪓🪔🪕🪖🪗🪘🪙🪚🪛🪜🪝🪞🪟🪠🪡🪢🪣🪤🪥🪦🪧🪨🪩🪪🪫🕺🪬🪰🪱🪲🪳🪴🖕🖖🖤🪵🪶🪷🪸🪹🪺🫀🫁🫂🫃🫄🫅🫐🫑🫒🫓🫔🫕🫖🫗🗻🗼🗽🗾🗿😀😁😂😃😄😅😆😇😈😉😊😋😌😍😎😏😐😑😒😓😔😕😖😗😘😙😚😛😜😝😞😟😠😡😢😣😤😥😦😧😨😩😪😫😬😭😮😯😰😱😲😳😴😵😶😷😸😹😺😻😼😽😾😿🙀🙁🙂🙃🙄🙅🙆🙇🙈🙉🙊🙌🙍🙎🙏🚀🚁🚂🚃🚄🚅🚆🚇🚈🚉🚊🚋🚌🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚙🚚🚛🚜🚝🚞🚟🚠🚡🚢🚣🚤🚥🚦🚧🚨🚩🚪🚫🚬🚭🚮🚯🚰🚱🚲🚳🚴🚵🚶🚷🚸🚹🚺🚻🚼🚽🚾🚿🛀🛁🛂🛃🛄🛅🫘🛌🫙🫠🫡🛐🛑🛒🫢🫣🫤🫥🫦🫧🫰🛫🛬🫱🫲🛴🛵🛶🛷🛸🛹🤐🤑🤒🤓🤔🤕🤖🤗🤘🤙🤚🤛🤜🤝🤞🤟🤠🤡🤢🤣🤤🤥🤦🤧🤨🤩🤪🤫🤬🤭🤮🤯🤰🤱🤲🤳🤴🤵🤶🤷🤸🤹🤺🤼🤽🤾🥀🥁🥂🥃🥄🥅🥇🥈🥉🥊🥋🥌🥍🥎🥏🥐🥑🥒🥓🥔🥕🥖🥗🥘🥙🥚🥛🥜🥝🥞🥟🥠🥡🥢🥣🥤🥥🥦🥧🥨🥩🥪🥫🥬🥭🥮🥯🥰🥳🥴🥵🥶🥺🥼🥽🥾🥿🦀🦁🦂🦃🦄🦅🦆🦇🦈🦉🦊🦋🦌🦍🦎🦏🦐🦑🦒🦓🦔🦕🦖🦗🦘🦙🦚🦛🦜🦝🦞🦟🦠🦡🦢🫳🫴🫵🫶🦴🦵🦶🦷🦸🦹🧀🧁🧂🧐🧑🧒🧓🧔🧕"],this.padChars.emojis_v2=["🥷","🛼","📑","🙋","☕"],this.#s(),this.converter=new BaseConverter(1024,5,4),this.padding=!0,this.padCharAmount=5,this.version="emojis_v1",this.isMutable.padding=!0,this.isMutable.trim=!0,this.trim=null,this.utils.converterArgs.trim=["notrim","trim"],this.utils.validateArgs(t,!0),null===this.trim&&(this.trim="emojis_v2"===this.version)}#s(){const t={},e=(t,e)=>{e.forEach((e=>{e in this.#r?this.#r[e].version+=t:this.#r[e]={version:t}}))},i=(e,i,r)=>{i.forEach((i=>{i in t?this.#r[i].version=3:(this.#r[i]={version:e,padding:r},t[i]=r)}))};e(1,this.charsets.emojis_v1),e(2,this.charsets.emojis_v2),i(1,this.padChars.emojis_v1.slice(0,-1),"last"),i(2,this.padChars.emojis_v2.slice(0,-1),"last"),i(1,this.padChars.emojis_v1.slice(-1),"fill"),i(2,this.padChars.emojis_v2.slice(-1),"fill");const r=[];for(const e in t)"last"===t[e]?r.push(e):r.push(`${e}+`);this.#n=new RegExp(r.join("|"),"g")}encode(t,...e){return super.encode(t,null,(({output:t,settings:e,zeroPadding:i})=>{const r=this.charsets[e.version];let n=[...t];if(i>1){const t=this.converter.padBytes(i);if(e.padding){const i=e.trim?1:t,r=new Array(i).fill(this.padChars[e.version].at(-1));n.splice(n.length-t,t,...r)}else n.splice(n.length-t,t)}else if(1===i){const t=r.indexOf(n.pop())>>8;n.push(this.padChars[e.version].at(t))}return n.join("")}),...e)}decode(t,...e){const i=this.utils.validateArgs(e);t=this.utils.normalizeInput(t);let r=i.version,n=null;"emojis_v1"!==i.version&&"emojis_v2"!==i.version||(n=3);const s=t=>{null!==n&&(n=this.#o(t,n,i.integrity),r=3===n?i.version:`emojis_v${n}`);const e=this.charsets[r],s=[...t],o=s.at(-1);let a=!1;for(let i=0;i<this.padChars[r].length-1;i++)if(o===this.padChars[r].at(i)){s.splice(-1,1,e.at(i<<8)),t=s.join(""),a=!0;break}let h=this.converter.decode(t,this.charsets[r],[],!1);return a&&(h=new Uint8Array(h.buffer.slice(0,-1))),h},o=[...t.matchAll(this.#n)];let a;if(o.length<2)a=s(t);else{const e=[];let i=0;o.forEach((r=>{const n=r.index+r.at(0).length;e.push(...s(t.slice(i,n))),i=n})),i!==t.length&&e.push(...s(t.slice(i,t.length))),a=Uint8Array.from(e)}return this.utils.outputHandler.compile(a,i.outputType)}#o(t,e,i){const r=[...t];let n;if(r.forEach(((t,r)=>{if(!(t in this.#r))throw new CharsetError(t);{const s=this.#r[t].version;if(3!==s)if(3===e)e=s;else if(e!==s)throw new TypeError(`Emojis from different ecoji versions seen : ${t} from emojis_v${s}`);if(i){const e=this.#r[t].padding;if(e){const i=r%4;if(n=!0,"fill"===e){if(0===i)throw new TypeError(`Padding unexpectedly seen in first position ${t}`)}else if(3!==i)throw new TypeError(`Last padding seen in unexpected position ${t}`)}else if(n)throw new TypeError("Unexpectedly saw non-padding after padding")}}})),i&&r.length%4&&(1===e||"fill"!==this.#r[r.at(-1)].padding))throw new TypeError("Unexpected end of data, input data size not multiple of 4");return e}}export{Ecoji as default};
