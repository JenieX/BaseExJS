/*
 * [BaseEx]{@link https://github.com/UmamiAppearance/BaseExJS}
 *
 * @version 0.4.0
 * @author UmamiAppearance [mail@umamiappearance.eu]
 * @license GPL-3.0 AND BSD-3-Clause (Base91, Copyright (c) 2000-2006 Joachim Henke)
 */
class Base16{constructor(...args){this.byteOrder="BE",this.charsets={default:"0123456789abcdef"},this.converter=new BaseConverter(16,1,2),this.converter.padGroups=[0],this.outputType="buffer",this.padding=!1,this.signed=!1,this.utils=new Utils(this),this.version="default",[this.version,this.signed,this.padding,this.outputType]=this.utils.validateArgs(args)}encode(input,...args){let version,signed,inputBytes,negative;[version,signed,,]=this.utils.validateArgs(args),[inputBytes,negative]=this.utils.smartInput.toBytes(input,signed);let output=this.converter.encode(inputBytes,this.charsets[version])[0];return output=this.utils.toSignedStr(output,signed,negative),output}decode(input,...args){let version,signed,outputType,negative;[version,signed,,outputType]=this.utils.validateArgs(args),input=String(input),[input,negative]=this.utils.extractSign(input),negative&&!signed&&this.utils.signError(),(input=(input=input.replace(/^0x/,"")).toLowerCase()).length%2&&(input="0".concat(input));let output=this.converter.decode(input,this.charsets[version]);return signed&&(output=this.utils.toSignedArray(output,negative)),this.utils.smartOutput.compile(output,outputType)}}class Base32{constructor(...args){this.byteOrder="BE",this.charsets={rfc3548:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",rfc4648:"0123456789ABCDEFGHIJKLMNOPQRSTUV",crockford:"0123456789ABCDEFGHJKMNPQRSTVWXYZ"},this.converter=new BaseConverter(32,5,8),this.converter.padGroups=[0,1,3,4,6],this.outputType="buffer",this.padding=!0,this.signed=!1,this.utils=new Utils(this),this.version="rfc4648",[this.version,this.signed,this.padding,this.outputType]=this.utils.validateArgs(args)}encode(input,...args){let version,signed,padding,inputBytes,negative,output,zeroPadding;if([version,signed,padding,,]=this.utils.validateArgs(args),[inputBytes,negative]=this.utils.smartInput.toBytes(input,signed),[output,zeroPadding]=this.converter.encode(inputBytes,this.charsets[version]),zeroPadding){const padValue=this.converter.padGroups[zeroPadding];output=output.slice(0,output.length-padValue),padding&&(output=output.concat("=".repeat(padValue)))}return output=this.utils.toSignedStr(output,signed,negative),output}decode(input,...args){let version,signed,outputType,negative;[version,signed,,outputType]=this.utils.validateArgs(args),input=String(input),[input,negative]=this.utils.extractSign(input),negative&&!signed&&this.utils.signError();const missingChars=(input=input.toUpperCase()).length%8;missingChars&&(input=input.padEnd(input.length+8-missingChars,"="));const output=this.converter.decode(input,this.charsets[version]);return this.utils.smartOutput.compile(output,outputType)}}class Base64{constructor(version="default",input="str",output="str",padding=!0){const b62Chars="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";this.charsets={default:b62Chars.concat("+/"),urlsafe:b62Chars.concat("-_")},this.padding=Boolean(padding),this.IOtypes=["str","bytes"],this.utils=new Utils(this),[this.version,this.defaultInput,this.defaultOutput]=this.utils.validateArgs([version,input,output]),this.converter=new BaseConverter(64,3,4),this.converter.padGroups=[0,1,2]}encode(input,...args){args=this.utils.validateArgs(args);const inputType=this.utils.setIOType(args,"in"),version=this.utils.getVersion(args);input=this.utils.validateInput(input,inputType);const inputBytes="str"===inputType?(new TextEncoder).encode(input):input;let output,zeroPadding;if([output,zeroPadding]=this.converter.encode(inputBytes,this.charsets[version]),zeroPadding){const padValue=this.converter.padGroups[zeroPadding];output=output.slice(0,output.length-padValue),this.padding&&(output=output.concat("=".repeat(padValue)))}return output}decode(input,...args){args=this.utils.validateArgs(args);const version=this.utils.getVersion(args),outputType=this.utils.setIOType(args,"out"),missingChars=input.length%4;missingChars&&(input=input.padEnd(input.length+4-missingChars,"="));const output=this.converter.decode(input,this.charsets[version]);return"bytes"===outputType?output:(new TextDecoder).decode(output)}}class Base85{constructor(version="ascii85",input="str",output="str",debug=!1){const asciiChars="!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstu";this.charsets={ascii85:asciiChars,adobe:asciiChars,rfc1924:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$%&()*+-;<=>?@^_`{|}~",z85:"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-:+=^!/*?&<>()[]{}@%$#"},this.IOtypes=["str","bytes"],this.utils=new Utils(this),this.expandUtils(debug),[this.version,this.defaultInput,this.defaultOutput]=this.utils.validateArgs([version,input,output]),this.converter=new BaseConverter(85,4,5),this.converter.padGroups=[0]}encode(input,...args){args=this.utils.validateArgs(args);const inputType=this.utils.setIOType(args,"in"),version=this.utils.getVersion(args);input=this.utils.validateInput(input,inputType);const inputBytes="str"===inputType?(new TextEncoder).encode(input):input;let replacer=null,output,zeroPadding;return version.match(/adobe|ascii85/)&&(replacer=(frame,zPad)=>zPad||"!!!!!"!==frame?frame:"z"),[output,zeroPadding]=this.converter.encode(inputBytes,this.charsets[version],replacer),output=output.slice(0,output.length-zeroPadding),"adobe"===version&&(output=`<~${output}~>`),"rfc1924"===version&&this.utils.announce(),output}decode(input,...args){args=this.utils.validateArgs(args);const version=this.utils.getVersion(args),outputType=this.utils.setIOType(args,"out");input=input.replace(/\s/g,""),version.match(/adobe|ascii85/)&&(input=input.replace(/z/g,"!!!!!"),"adobe"===version&&(input=input.replace(/^<~|~>$/g,"")));const output=this.converter.decode(input,this.charsets[version]);return"bytes"===outputType?output:(new TextDecoder).decode(output)}expandUtils(debug){this.utils.announce=()=>{if(!debug){const date=new Date;if(3===date.getMonth()&&1===date.getDate())console.log("         __\n _(\\    |@@|\n(__/\\__ \\--/ __\n   \\___|----|  |   __\n       \\ }{ /\\ )_ / _\\\n       /\\__/\\ \\__O (__\n      (--/--)    \\__/\n      _)(  )(_\n     `---''---`");else{const ts=date.getTime();date.setMonth(3,1),date.setHours(0,0,0),date.getTime()<ts&&date.setFullYear(date.getFullYear()+1);const dist=date-ts,d=Math.floor(dist/864e5),H=Math.floor(dist%864e5/36e5),M=Math.floor(dist%36e5/6e4),msg=`Time left: ${d} days, ${H} hours, ${M} minutes`;Utils.warning("Only the charset is used. The input is not taken as a 128 bit integer. (because this is madness)"),Utils.warning(msg)}}}}}class Base91{constructor(version="default",input="str",output="str"){this.charsets={default:'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,./:;<=>?@[]^_`{|}~"'},this.IOtypes=["str","bytes"],this.utils=new Utils(this),this.utils.divmod=(x,y)=>[Math.floor(x/y),x%y],[this.version,this.defaultInput,this.defaultOutput]=this.utils.validateArgs([version,input,output])}encode(input,...args){args=this.utils.validateArgs(args);const inputType=this.utils.setIOType(args,"in"),version=this.utils.getVersion(args);input=this.utils.validateInput(input,inputType);const inputBytes="str"===inputType?(new TextEncoder).encode(input):input;let bitCount=0,n=0,output="";const chars=this.charsets[version];if(inputBytes.forEach(byte=>{if(n+=byte<<bitCount,bitCount+=8,bitCount>13){let count=13,rN=n%8192,q,r;rN<89&&(count=14,rN=n%16384),n>>=count,bitCount-=count,[q,r]=this.utils.divmod(rN,91),output=`${output}${chars[r]}${chars[q]}`}}),bitCount){let q,r;[q,r]=this.utils.divmod(n,91),output=output.concat(chars[r]),(bitCount>7||n>90)&&(output=output.concat(chars[q]))}return output}decode(input,...args){args=this.utils.validateArgs(args);const version=this.utils.getVersion(args),outputType=this.utils.setIOType(args,"out");let l=(input=input.replace(/\s/g,"")).length,odd=!1;l%2&&(odd=!0,l--);let n=0,bitCount=0;const chars=this.charsets[version],b256Array=new Array;for(let i=0;i<l;i+=2){const rN=chars.indexOf(input[i])+91*chars.indexOf(input[i+1]);n=(rN<<bitCount)+n,bitCount+=rN%8192>88?13:14;do{b256Array.push(n%256),n>>=8,bitCount-=8}while(bitCount>7)}if(odd){const lastChar=input.charAt(l),rN=chars.indexOf(lastChar);b256Array.push(((rN<<bitCount)+n)%256)}const output=Uint8Array.from(b256Array);return"bytes"===outputType?output:(new TextDecoder).decode(output)}}class BaseConverter{constructor(radix,bsEnc=null,bsDec=null){this.radix=radix,null!==bsEnc&&null!==bsDec?(this.bsEnc=bsEnc,this.bsDec=bsDec):[this.bsEnc,this.bsDec]=this.constructor.calcBS(radix),this.powers=[];for(let i=0;i<this.bsDec;i++)this.powers.unshift(BigInt(radix**i))}static calcBS(radix){let bsDecPre=Math.ceil(256/radix);bsDecPre>8&&!(bsDecPre%8)&&(bsDecPre/=8);let bsEnc=0;for(;8*bsEnc*Math.log(2)/Math.log(radix)<bsDecPre;)bsEnc++;const bsDec=Math.ceil(8*bsEnc*Math.log(2)/Math.log(radix));return[bsEnc,bsDec]}encode(inputBytes,charset,replacer=null){let output="",zeroPadding=0;const bs=this.bsEnc;for(let i=0,l=inputBytes.length;i<l;i+=bs){let n=0n;for(let j=i;j<i+bs;j++){let byte;j>=l?(byte=0,zeroPadding++):byte=inputBytes[j],n=(n<<8n)+BigInt(byte)}const bXarray=new Array;let q=n,r;for(;q>=this.radix;)[q,r]=this.divmod(q,this.radix),bXarray.unshift(parseInt(r,10));for(bXarray.unshift(parseInt(q,10)),console.log(bXarray);bXarray.length<this.bsDec;)bXarray.unshift(0);let frame="";bXarray.forEach(charIndex=>frame=frame.concat(charset[charIndex])),replacer&&(frame=replacer(frame,zeroPadding)),output=output.concat(frame)}return[output,zeroPadding]}decode(inputBaseStr,charset){const bs=this.bsDec,byteArray=new Array;inputBaseStr.split("").forEach(c=>{const index=charset.indexOf(c);index>-1&&byteArray.push(index)});const padChars=(bs-byteArray.length%bs)%bs;for(let i=0;i<padChars;i++)byteArray.push(this.radix-1);const inputBytes=Uint8Array.from(byteArray);let b256Array=new Array;for(let i=0,l=inputBaseStr.length;i<l;i+=bs){let n=0n;for(let j=0;j<bs;j++)n+=BigInt(inputBytes[i+j])*this.powers[j];const subArray256=new Array;let q=n,r;for(;q>=256;)[q,r]=this.divmod(q,256),subArray256.unshift(parseInt(r,10));for(subArray256.unshift(parseInt(q,10));subArray256.length<this.bsEnc;)subArray256.unshift(0);b256Array=b256Array.concat(subArray256)}const padding=this.padGroups.indexOf(padChars);b256Array.splice(b256Array.length-padding);const output=Uint8Array.from(b256Array);return output}divmod(x,y){return[x,y]=[BigInt(x),BigInt(y)],[parseInt(x/y,10),parseInt(x%y,10)]}}class Utils{constructor(main){this.root=main,"charsets"in main&&this.charsetUserToolsConstructor(),this.smartInput=new SmartInput,this.smartOutput=new SmartOutput}charsetUserToolsConstructor(){this.root.addCharset=(name,charset)=>{if("string"!=typeof name)throw new TypeError("The charset name must be a string.");const setLen=this.root.converter.radix;let inputLen=setLen;if("string"==typeof charset||Array.isArray(charset))inputLen=charset.length,charset=new Set(charset);else if(!(charset instanceof Set))throw new TypeError("The charset must be one of the types:\n'str', 'set', 'array'.");if(charset.size!==setLen)throw inputLen===setLen?new Error("There were repetitive chars found in your charset. Make sure each char is unique."):new Error(`The the length of the charset must be ${setLen}.`);charset=[...charset].join(""),this.root.charsets[name]=charset,console.log(`New charset added with the name '${name}' added and ready to use`)},this.root.setDefaultVersion=version=>[this.root.version]=this.validateArgs([version])}makeArgList(args){return args.map(s=>`'${s}'`).join(", ")}toSignedStr(output,signed,negative){return signed&&(output=output.replace(/^0+/,"")),negative&&(output="-".concat(output)),output}extractSign(input){let negative=!1;return"-"===input[0]&&(negative=!0,input=input.slice(1)),[input,negative]}normalizeOutput(array){let bytesPerElem=2**Math.ceil(Math.log(array.byteLength)/Math.log(2));bytesPerElem=Math.max(bytesPerElem,2);const byteDelta=bytesPerElem-array.byteLength;if(byteDelta){const normalizedArray=new Uint8Array(bytesPerElem);normalizedArray.set(array,byteDelta),array=normalizedArray}return array}negate(array){array.forEach((b,i)=>array[i]=255^b);const lastElem=array.byteLength-1;array[lastElem]+=1}toSignedArray(array,negative){return array=this.normalizeOutput(array),negative&&this.negate(array),array}validateArgs(args){let versions=Object.keys(this.root.charsets);const outputTypes=this.smartOutput.typeList,signedArgs=["signed","unsigned"],padArgs=["pad","nopad"],validArgs=[...outputTypes,...versions,...padArgs,...signedArgs];let version=this.root.version,signed=this.root.signed,padding=this.root.padding,outputType="buffer";return args.length&&args.forEach(arg=>{if(arg=String(arg).toLowerCase(),!validArgs.includes(arg)){const signedHint="'signed' to disable, 'unsigned', to enable the use of the twos's complement for negative integers.",padHint="'pad' to fill up, 'nopad' to not fill up the output with the particular padding.",outputHint=`Valid args for the output type are ${this.makeArgList(outputTypes)}`,versionHint=versions?`The options for version (charset) are: ${this.makeArgList(versions)}`:"";throw new TypeError(`'${arg}'\nValid parameters are:\n * ${signedHint}\n * ${padHint}\n * ${outputHint}\n * ${versionHint}\n\nTraceback:`)}versions.includes(arg)?version=arg:outputTypes.includes(arg)?outputType=arg:"signed"===arg?signed=!0:"unsigned"===arg?signed=!1:"pad"===arg?padding=!0:"nopad"===arg&&(padding=!1)}),padding&&signed&&(padding=!1,this.constructor.warning("Padding was set to false due to the signed conversion.")),[version,signed,padding,outputType]}signError(){throw new TypeError("The input is signed but the converter is not set to treat input as signed.\nYou can pass the string 'signed' to the decode function or when constructing the converter.")}static warning(message){Object.prototype.hasOwnProperty.call(console,"warn")?console.warn(message):console.log(`___\n${message}\n`)}}class SmartInput{makeDataView(byteLen){const buffer=new ArrayBuffer(byteLen);return new DataView(buffer)}floatingPoints(input,littleEndian=!1){let view;if(input>12e-39&&input<34e37)view=this.makeDataView(4),view.setFloat32(0,input,littleEndian);else{if(!(input>23e-309&&input<17e307))throw new RangeError("Float is too complex to handle. Convert it to bytes manually before encoding.");view=this.makeDataView(8),view.setFloat64(0,input,littleEndian)}return view}numbers(input,littleEndian=!1){let view;if(Number.isInteger(input)){if(!Number.isSafeInteger(input)){let safeInt,smallerOrBigger,minMax;input<0?(safeInt=Number.MIN_SAFE_INTEGER,smallerOrBigger="smaller",minMax="MIN"):(safeInt=Number.MAX_SAFE_INTEGER,smallerOrBigger="bigger",minMax="MAX"),Utils.warning(`The provided integer is ${smallerOrBigger} than ${minMax}_SAFE_INTEGER: '${safeInt}'\nData loss is possible. Use a BigInt to avoid this issue.`)}input<0?input<-2147483648?(view=this.makeDataView(8),view.setBigInt64(0,BigInt(input),littleEndian)):input<-32768?(view=this.makeDataView(4),view.setInt32(0,input,littleEndian)):(view=this.makeDataView(2),view.setInt16(0,input,littleEndian)):input>0?input>4294967295?(view=this.makeDataView(8),view.setBigUint64(0,BigInt(input),littleEndian)):input>65535?(view=this.makeDataView(4),view.setUint32(0,input,littleEndian)):(view=this.makeDataView(2),view.setInt16(0,input,littleEndian)):view=new Uint16Array([0])}else view=this.floatingPoints(input,littleEndian);return new Uint8Array(view.buffer)}bigInts(input,littleEndian=!1){const byteArray=new Array;if(input>0){const overflow=18446744073709551616n;for(;input>=overflow;)byteArray.unshift(input%overflow),input>>=64n}else if(input<0){const overflow=-9223372036854775808n;for(;input<=overflow;)byteArray.unshift(input%overflow),input>>=64n}byteArray.unshift(input);const byteLen=8*byteArray.length,buffer=new ArrayBuffer(byteLen),view=new DataView(buffer);return byteArray.forEach((bigInt,i)=>{const offset=8*i;view.setBigUint64(offset,bigInt,littleEndian)}),new Uint8Array(view.buffer)}toBytes(input,signed,littleEndian=!1){let inputUint8,negative=!1;if(input instanceof ArrayBuffer)inputUint8=new Uint8Array(input);else if(ArrayBuffer.isView(input))inputUint8=new Uint8Array(input.buffer);else if("string"==typeof input||input instanceof String)inputUint8=(new TextEncoder).encode(input);else if("number"!=typeof input||isNaN(input)||input===1/0)if("bigint"==typeof input)signed&&input<0&&(negative=!0,input*=-1n),inputUint8=this.bigInts(input,littleEndian);else{if(!Array.isArray(input))throw new TypeError("The provided input type can not be processed.");{const collection=new Array;for(const elem of input)collection.push(...this.toBytes(elem));inputUint8=Uint8Array.from(collection)}}else signed&&input<0&&(negative=!0,input*=-1),inputUint8=this.numbers(input,littleEndian);return[inputUint8,negative]}}class SmartOutput{constructor(){this.typeList=this.constructor.validTypes()}getType(type){if(!this.typeList.includes(type))throw new TypeError(`Unknown output type: '${type}'`);return type}compile(Uint8ArrayOut,type){let compiled;return"buffer"===(type=this.getType(type))?compiled=Uint8ArrayOut.buffer:"bytes"==type?compiled=Uint8ArrayOut:"str"===type&&(compiled=(new TextDecoder).decode(Uint8ArrayOut)),compiled}static validTypes(){const typeList=["buffer","bytes","str"];return typeList}}class BaseEx{constructor(input="str",output="str"){this.base16=new Base16("default",input,output),this.base32_rfc3548=new Base32("rfc3548",input,output),this.base32_rfc4648=new Base32("rfc4648",input,output),this.base64=new Base64("default",input,output),this.base64_urlsafe=new Base64("urlsafe",input,output),this.base85adobe=new Base85("adobe",input,output),this.base85ascii=new Base85("ascii85",input,output),this.base85_z85=new Base85("z85",input,output),this.base91=new Base91("default",input,output)}}export{Base16,Base32,Base64,Base85,Base91,BaseEx};